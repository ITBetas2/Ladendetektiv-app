<!DOCTYPE html>

<html lang="de">
<head>
<!-- PWA / App Icons -->
<link rel="manifest" href="/manifest.webmanifest">
<link rel="icon" href="/favicon.ico">
<link rel="apple-touch-icon" sizes="180x180" href="/icons/icon-180x180.png">
<meta name="theme-color" content="#0b1a3a">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Ladendetektive</title>
<style>
    /* ========= DESIGN: NUR FARBEN ANPASSEN ========= */
    :root{
      --bg: #0b1020;
      --panel: #111a33;
      --panel2: #0f1730;
      --text: #e8ecff;
      --muted: #aab3da;
      --brand: #4da3ff;
      --accent: #7c5cff;
      --ok: #2ee59d;
      --bad: #ff4d6d;
      --border: rgba(255,255,255,.10);
      --shadow: 0 14px 40px rgba(0,0,0,.45);
      --chip: rgba(255,255,255,.08);
      --danger: #ff4d6d;
      --warn: #ffcc66;
      --safeBottom: env(safe-area-inset-bottom, 0px);
      --navH: 72px;
    }

    *{ box-sizing:border-box; }
    html,body{ min-height:100dvh; height:auto; overflow-x:hidden; overflow-y:auto; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 700px at 15% 10%, rgba(77,163,255,.16), transparent 60%),
                  radial-gradient(1100px 700px at 85% 30%, rgba(124,92,255,.14), transparent 60%),
                  var(--bg);
      color: var(--text);
    }

    .app{
      display:grid;
      grid-template-columns: 280px 1fr 380px;
      grid-template-rows: 1fr;
      gap:14px;
      height:100%;
      min-height:0;
      padding:14px;
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: var(--shadow);
      overflow:hidden;
      min-height: 0;
    }

    .sidebar, .rightbar { display:flex; flex-direction:column; }
    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:14px 14px 12px;
      border-bottom: 1px solid var(--border);
      background: rgba(0,0,0,.14);
    }
    .brand{
      display:flex; align-items:center; gap:10px; min-width:0;
    }
    .logo{
      width:36px; height:36px;
      border-radius: 12px;
      display:grid; place-items:center;
      background: rgba(77,163,255,.18);
      border:1px solid var(--border);
      user-select:none;
      font-weight:700;
    }
    .brand h1{
      font-size:14px; margin:0;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .sub{ font-size:12px; color: var(--muted); margin-top:2px; }

    .statusDot{
      width:10px; height:10px; border-radius:999px;
      background: var(--bad);
      box-shadow: 0 0 0 4px rgba(255,77,109,.12);
    }
    .statusDot.ok{
      background: var(--ok);
      box-shadow: 0 0 0 4px rgba(46,229,157,.12);
    }

    .btn{
      border:1px solid var(--border);
      background: rgba(255,255,255,.06);
      color: var(--text);
      border-radius: 12px;
      padding:10px 12px;
      cursor:pointer;
      font-weight:600;
      transition: transform .04s ease, background .15s ease;
      user-select:none;
    }
    .btn:hover{ background: rgba(255,255,255,.10); }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{
      background: linear-gradient(135deg, rgba(77,163,255,.35), rgba(124,92,255,.25));
      border-color: rgba(77,163,255,.35);
    }
    .btn.danger{
      background: rgba(255,77,109,.12);
      border-color: rgba(255,77,109,.35);
    }
    .btn.small{ padding:8px 10px; border-radius: 10px; font-size:12px; }
    .btn.row{ width:100%; text-align:left; }

    .section{
      padding:12px 14px;
      border-bottom: 1px solid var(--border);
    }

    .field{
      display:flex; flex-direction:column; gap:6px; margin-top:10px;
    }
    .field label{ font-size:12px; color: var(--muted); }
    input, select, textarea{
      width:100%;
      padding:10px 11px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.25);
      color: var(--text);
      outline:none;
    }
    textarea{ resize:none; min-height: 90px; }

    .list{
      padding:10px;
      overflow:auto;
      min-height:0;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .item{
      display:flex; align-items:center; gap:10px;
      padding:10px 10px;
      border-radius: 14px;
      border:1px solid var(--border);
      background: rgba(0,0,0,.18);
    }
    .item .meta{ min-width:0; flex:1; }
    .item .title{
      font-weight:700; font-size:13px;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .item .desc{
      font-size:12px; color: var(--muted);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      margin-top:2px;
    }
    .chip{
      font-size:11px;
      background: var(--chip);
      border:1px solid var(--border);
      padding:4px 8px;
      border-radius: 999px;
      color: var(--muted);
      white-space:nowrap;
    }

    .main{
      display:flex;
      flex-direction:column;
      min-height:0;
    }

    .mainHeader{
      padding:14px;
      border-bottom: 1px solid var(--border);
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      background: rgba(0,0,0,.12);
    }

    .searchRow{ display:flex; gap:10px; align-items:center; width:100%; }
    .searchRow input{ flex:1; }

    .dropzone{
      margin:14px;
      border:2px dashed rgba(255,255,255,.18);
      background: rgba(0,0,0,.12);
      border-radius: 18px 18px 0 0;
      padding:18px;
      text-align:center;
      color: var(--muted);
      transition: background .15s ease, border-color .15s ease;
    }
    .dropzone.drag{
      background: rgba(77,163,255,.10);
      border-color: rgba(77,163,255,.45);
      color: var(--text);
    }

    .grid{
      padding:0 14px 14px;
      overflow:auto;
      min-height:0;
      display:grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap:10px;
    }
    .fileCard{
      border:1px solid var(--border);
      background: rgba(0,0,0,.16);
      border-radius: 16px;
      padding:12px;
      display:flex; flex-direction:column; gap:8px;
      min-width:0;
    }
    .fileCard .row{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .fileCard .name{
      font-weight:600;
      font-size:13px;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .fileCard .small{
      font-size:12px; color: var(--muted);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .fileCard .actions{ display:flex; gap:8px; flex-wrap:wrap; }

    .chat{
      display:flex; flex-direction:column; min-height:0;
    }
    .chatLog{
      padding:12px;
      overflow:auto;
      min-height:0;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .bubble{
      max-width: 85%;
      padding:10px 12px;
      border-radius: 14px;
      border:1px solid var(--border);
      background: rgba(0,0,0,.20);
      color: var(--text);
    }
    .bubble.me{
      align-self:flex-end;
      background: rgba(77,163,255,.14);
      border-color: rgba(77,163,255,.30);
    }
    .bubble .t{
      font-size:12px; color: var(--muted); margin-top:6px;
    }
    .chatInput{
      display:flex; gap:10px;
      padding:12px;
      border-top:1px solid var(--border);
      background: rgba(0,0,0,.12);
    }
    .chatInput input{ flex:1; }

    .row2{ display:flex; gap:10px; }
    .hint{ font-size:12px; color: var(--muted); line-height:1.35; }
    .hidden{ display:none !important; }

    @media (max-width: 980px){

      .mobileHeader{ display:flex;

  /* Mobile Startseite: besser lesbar & klickfreundlich */
  #startPanel{
    width: 100%;
    max-width: 100%;
    margin: 0;
  }
  #startPanel .topbar{
    flex-direction: column;
    align-items: flex-start;
    gap: 10px;
  }
  #startPanel .chip{
    align-self: flex-start;
  }
  #startPanel .section{
    padding: 12px 0;
  }
  #startPanel #updatesBox{
    font-size: 14px;
    line-height: 1.5;
  }
  #startPanel .row2{
    display: grid;
    grid-template-columns: 1fr;
    gap: 10px;
  }
  #startPanel .row2 .btn{
    width: 100%;
    min-height: 48px;
    font-size: 15px;
    padding: 12px 14px;
  }

  /* Generell: gr√∂√üere Touch-Ziele im Mobile */
  #mobileBottomNav .mbtn{
    min-width: 56px;
  }
  #mobileBottomNav .mbtn .ico{
    font-size: 18px;
  }
  #mobileBottomNav .mbtn .lbl{
    font-size: 11px;
  }


}
.viewport{ padding-top: var(--mobHeaderH); }
      .app{
        grid-template-columns: 1fr;
        padding: 12px;
      /* Mobile: prevent bottom nav overlay by shrinking the fixed viewport */
      .viewport{
        inset: 0 0 calc(var(--navH) + var(--safeBottom)) 0;
      }

      }
      .sidebar, .rightbar{
        display:none;
      }
      .main{
        grid-column: 1 / -1;
      }
      .grid{
        grid-template-columns: 1fr;
      }
      .dropzone{
        margin: 12px;
      }
      .mainHeader{
        position: sticky;
        top: 0;
        z-index: 5;
      }
}

    /* Tablet: 2 columns, hide rightbar */
    @media (min-width: 981px) and (max-width: 1250px){
      .app{
        grid-template-columns: 280px 1fr;
      }
      .rightbar{
        display:none;
      }
      .grid{
        grid-template-columns: repeat(2, minmax(0,1fr));
      }
    }
  
    /* Mobile Safari fix: prevent auto-zoom/jump on form focus (iOS zooms if font-size < 16px) */
    @media (max-width: 900px){
      input, select, textarea{ font-size:16px; }
      body{ min-height:100dvh; }
      .app{ height:auto; min-height:100dvh; }
    }


/* --- Viewport/Keyboard/Jank fix (Android/WebView) --- */
html, body { height: 100%; }
body { overflow: hidden; }
.viewport{
  position: fixed;
  inset: 0;
  height: 100dvh;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: contain;
}



/* Ensure columns fill viewport and internal areas scroll */
.sidebar, .main, .rightbar{ height:100%; min-height:0; }
/* Chat: eigener scrollbarer Container */
.rightbar{ display:flex; flex-direction:column; min-height:0; }
.rightbar .chat{ display:flex; flex-direction:column; flex:1; min-height:0; }
.rightbar .chatLog{ flex:1; min-height:160px; overflow:auto; }

/* Prevent accidental page jump on focus (keep within viewport) */
input, textarea, select { scroll-margin-top: 90px; }

  /* Auth-Gate (Login zuerst) */
  .authOverlay{
    position:fixed; inset:0;
    display:flex; align-items:center; justify-content:center;
    padding:18px;
    background:rgba(0,0,0,.55);
    backdrop-filter: blur(6px);
    z-index:9999;
  }
  .authModal{
    width:min(520px, 100%);
    max-height: 90dvh;
    overflow:auto;
  }

  /* Admin-Men√º am Desktop breiter (Mobile bleibt wie bisher) */
  @media (min-width: 980px){
    #adminOverlay .authModal{
      width: min(920px, 96vw);
    }
  }

  /* --- Admin UI Refresh (Tabs + Grid) --- */
  #adminOverlay .adminModal{ padding: 14px 14px 16px; }
  #adminOverlay .adminHeader{
    display:flex; align-items:center; justify-content:space-between; gap:10px;
    position: sticky; top:0;
    padding: 2px 0 10px;
    background: linear-gradient(180deg, rgba(17,26,51,.92), rgba(17,26,51,.75));
    backdrop-filter: blur(10px);
    z-index: 2;
    border-bottom: 1px solid rgba(255,255,255,.08);
  }

  #adminOverlay .adminLayout{
    display:flex; gap:12px;
    margin-top: 12px;
    min-height: 0;
  }

  #adminOverlay .adminNav{
    display:flex; flex-direction:column; gap:8px;
    min-width: 170px;
    position: sticky;
    top: 56px;
    align-self:flex-start;
  }
  #adminOverlay .adminNavBtn{
    width:100%;
    text-align:left;
    border:1px solid var(--border);
    background: rgba(255,255,255,.06);
    color: var(--text);
    border-radius: 14px;
    padding: 10px 12px;
    cursor:pointer;
    font-weight: 900;
    font-size: 13px;
  }
  #adminOverlay .adminNavBtn.active{
    background: linear-gradient(135deg, rgba(77,163,255,.28), rgba(124,92,255,.22));
    border-color: rgba(77,163,255,.35);
  }

  #adminOverlay .adminContent{ flex:1; min-width:0; }
  #adminOverlay .adminCard{
    border:1px solid rgba(255,255,255,.10);
    background: rgba(0,0,0,.18);
    border-radius: 16px;
    padding: 14px;
    box-shadow: var(--shadow);
  }
  #adminOverlay .adminCardTitle{
    font-weight: 950;
    letter-spacing: .2px;
    font-size: 14px;
  }
  #adminOverlay .adminTextarea{
    width:100%;
    min-height:140px;
    resize: vertical;
    padding:10px;
    border-radius:12px;
    border:1px solid var(--border);
    background: rgba(0,0,0,.22);
    color: var(--text);
    margin-top: 10px;
  }
  #adminOverlay .divider{
    height:1px;
    background: rgba(255,255,255,.10);
    margin: 14px 0;
    border-radius: 999px;
  }
  #adminOverlay .adminGrid2{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:12px;
  }
  #adminOverlay .adminTableWrap{
    overflow:auto;
    max-height: 52dvh;
    padding-right: 2px;
  }
  #adminOverlay .adminTable{
    width:100%;
    border-collapse:separate;
    border-spacing:0 8px;
  }

  /* Mobile: Tabs oben, Inhalte darunter (Handy bleibt kompakt) */
  @media (max-width: 979px){
    #adminOverlay .adminLayout{ display:block; }
    #adminOverlay .adminNav{
      flex-direction: row;
      overflow:auto;
      gap:8px;
      min-width:0;
      padding-bottom: 8px;
      top: 56px;
    }
    #adminOverlay .adminNavBtn{
      white-space:nowrap;
      width:auto;
      text-align:center;
    }
    #adminOverlay .adminGrid2{ grid-template-columns: 1fr; }
    #adminOverlay .adminTableWrap{ max-height: 44dvh; }
  }

  .authTitle{ font-weight:900; font-size:18px; margin-bottom:10px; }
  /* Android/iOS Keyboard: verhindert Zoom/Jump */
  .authOverlay input, .authOverlay select, .authOverlay textarea{ font-size:16px; }
  .hidden{ display:none !important; }

    .presenceBar{
      display:flex; align-items:center; gap:8px;
      padding-left:10px;
      flex-shrink:0;
    }
    .avatarStack{ display:flex; align-items:center; }
    .avatar{
      width:30px; height:30px; border-radius:999px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.06);
      overflow:hidden;
      display:grid; place-items:center;
      position:relative;
      margin-left:-8px;
    }
    .avatar:first-child{ margin-left:0; }
    .avatar img{ width:100%; height:100%; object-fit:cover; display:block; }
    .onlineDot{
      position:absolute; right:-1px; bottom:-1px;
      width:10px; height:10px; border-radius:999px;
      background: var(--ok);
      box-shadow: 0 0 0 3px rgba(17,26,51,.95);
      border:1px solid rgba(255,255,255,.18);
    }
    .presenceLabel{ font-size:12px; color: var(--muted); white-space:nowrap; }


    /* ========= DESKTOP NAV (wie Mobile-Men√º) ========= */
    .desktopNavBar{
      display:none;
      position: sticky;
      top:0;
      z-index: 30;
      margin: 0 14px;
      border-radius: 18px;
      border:1px solid var(--border);
      background: rgba(0,0,0,.22);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
    }
    .desktopNavInner{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
    }
    .tabs{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .tabBtn{
      border:1px solid var(--border);
      background: rgba(255,255,255,.06);
      color: var(--text);
      border-radius: 999px;
      padding:8px 12px;
      cursor:pointer;
      font-weight:600;
      font-size:12px;
      user-select:none;
    }
    .tabBtn.active{
      background: linear-gradient(135deg, rgba(77,163,255,.35), rgba(124,92,255,.25));
      border-color: rgba(77,163,255,.35);
    }
    .tabRight{
      display:flex;
      align-items:center;
      gap:10px;
      min-width:0;
    }

    /* Desktop: ‚ÄûCompact View‚Äú statt 3-Spalten */
    @media (min-width: 981px){
      .desktopNavBar{ display:block; }
      .app{
        grid-template-columns: 1fr;
      }
      .sidebar, .rightbar{ display:none; }
      #startPanel{ display:none; } /* wird via JS aktiviert */
      body{ padding-top: 0; }
    }


    .dateSep{
      display:flex;
      align-items:center;
      gap:10px;
      margin: 6px 0;
      color: var(--muted);
      font-size:12px;
      user-select:none;
    }
    .dateSep::before, .dateSep::after{
      content:"";
      flex:1;
      height:1px;
      background: var(--border);
    }
    .bubble{ position:relative; }
    .delMsgBtn{
      position:absolute;
      top:6px;
      right:6px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.06);
      color: var(--muted);
      border-radius: 10px;
      padding:4px 8px;
      font-size:11px;
      cursor:pointer;
    }
    .delMsgBtn:hover{ background: rgba(255,77,109,.12); color: var(--text); border-color: rgba(255,77,109,.35); }


/* ===== Mobile Setup v48 ===== */
@media (max-width: 900px){
  .topnav{ display:none !important; }
  .mobileHeader{ display:none !important; } /* we use bottom nav instead */
  #mobileBottomNav{ display:flex !important; }
  .viewport{ padding-bottom:72px; } /* space for bottom nav */
  #mainPanel, #rightbar, #sidebar{ width:100% !important; }
  #rightbar{ margin-left:0 !important; }
  .card{ margin:10px; }
}
#mobileBottomNav{
  display:none;
  position:fixed;
  left:0; right:0; bottom:0;
  height:64px;
  padding:8px 10px;
  gap:8px;
  background: rgba(10,14,28,.92);
  border-top:1px solid var(--border);
  backdrop-filter: blur(10px);
  z-index: 40;
  align-items:center;
  justify-content:space-between;
}
#mobileBottomNav .mbtn{
  flex:1;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap:4px;
  padding:6px 4px;
  border-radius:14px;
  border:1px solid transparent;
  background: rgba(255,255,255,.04);
  color: var(--text);
  font-size:11px;
}
#mobileBottomNav .mbtn.active{
  border-color: rgba(77,163,255,.45);
  background: rgba(77,163,255,.10);
}
#mobileBottomNav .mbtn span{
  font-size:16px;
}

/* =========================================================
   MOBILE-ONLY BUNDLE (override)
   -> ganz ans ENDE deiner <style> setzen
   Breakpoint: <= 900px (iOS/Android)
========================================================= */
@media (max-width: 900px){

  /* ---------- Base / Layout ---------- */
  :root{
    --navH: 72px; /* deine Bottom-Nav H√∂he */
  }

  html, body{
    height: 100%;
  }

  /* Fixed viewport + Scroll im Container (dein Ansatz) */
  body{
    overflow: hidden;
  }

  .viewport{
    position: fixed;
    inset: 0;
    height: 100dvh;
    overflow: auto;
    -webkit-overflow-scrolling: touch;
    overscroll-behavior: contain;

    /* Platz f√ºr Bottom-Nav + Safe-Area */
    padding-bottom: calc(var(--navH) + var(--safeBottom));
    padding-top: 0;
  }

  /* App Shell: weniger Padding */
  .app{
    grid-template-columns: 1fr !important;
    padding: 8px !important;
    gap: 10px !important;
    height: auto !important;
    min-height: 100dvh !important;
  }

  /* Desktop/Sidebars auf Mobile aus, wie bei dir */
  .sidebar, .rightbar{ display: none !important; }
  .main{ grid-column: 1 / -1; }

  /* ---------- Cards: weniger ‚Äûzerkl√ºftet‚Äú ---------- */
  .card{
    margin: 6px 4px !important;
    border-radius: 14px !important;
    box-shadow: var(--shadow);
  }

  .topbar{
    padding: 12px 12px 10px !important;
    gap: 10px !important;
  }

  .section{
    padding: 10px 12px !important;
  }

  /* ---------- Forms: iOS Zoom vermeiden + ruhiger ---------- */
  input, select, textarea{
    font-size: 16px !important; /* iOS no-zoom */
    padding: 11px 12px !important;
    border-radius: 12px !important;
  }

  textarea{ min-height: 96px !important; }

  /* ---------- Buttons: gro√üe Touch-Ziele + Full Width ---------- */
  .btn{
    width: 100%;
    min-height: 48px;
    padding: 12px 14px;
    border-radius: 14px;
    font-size: 15px;
  }

  .btn.small{
    min-height: 44px;
    padding: 10px 12px;
    font-size: 14px;
    border-radius: 12px;
  }

  /* Row2 wird auf Mobile immer ‚Äûuntereinander‚Äú */
  .row2{
    display: grid !important;
    grid-template-columns: 1fr !important;
    gap: 10px !important;
  }

  /* ---------- Start Panel: wie ‚ÄûApp Startseite‚Äú ---------- */
  #startPanel{
    width: 100% !important;
    max-width: 100% !important;
    margin: 6px 4px !important;
  }

  #startPanel .topbar{
    flex-direction: column;
    align-items: flex-start;
  }

  #startPanel .row2{
    grid-template-columns: 1fr !important;
  }

  #startPanel #updatesBox{
    font-size: 14px;
    line-height: 1.5;
  }

  /* ---------- Main Header / Suche: stapeln & kompakter ---------- */
  .mainHeader{
    position: sticky;
    top: 0;
    z-index: 10;
    padding: 10px !important;
    background: rgba(0,0,0,.20);
    backdrop-filter: blur(10px);
  }

  .searchRow{
    flex-direction: column !important;
    align-items: stretch !important;
    gap: 8px !important;
    width: 100% !important;
  }

  #typeFilter{
    max-width: 100% !important;
  }

  #btnNotify{
    width: 100% !important;
  }

  /* ---------- Dropzone: weniger H√∂he, cleaner ---------- */
  .dropzone{
    margin: 10px !important;
    padding: 14px !important;
    border-radius: 16px !important;
  }

  .dropzone .hint{
    line-height: 1.45;
  }

  /* ---------- Grid: 1 Spalte, Karten ruhiger ---------- */
  .grid{
    grid-template-columns: 1fr !important;
    padding: 0 10px 10px !important;
    gap: 10px !important;
  }

  .fileCard{
    border-radius: 16px !important;
    padding: 12px !important;
    gap: 10px !important;
  }

  .fileCard .row{
    gap: 10px !important;
  }

  .fileCard .name{
    font-size: 14px !important;
    line-height: 1.2;
  }

  .fileCard .small{
    font-size: 12.5px !important;
    line-height: 1.4;
    white-space: normal !important; /* weniger ‚Äû1-line‚Äú-Abschneiden */
  }

  /* Actions als 2-Spalten Grid */
  .fileCard .actions{
    display: grid !important;
    grid-template-columns: 1fr 1fr !important;
    gap: 8px !important;
  }

  .fileCard .actions .btn{
    width: 100% !important;
  }

  /* ---------- Chat Panel: wenn du chat view aktivierst ---------- */
  .chatLog{
    padding: 10px !important;
    gap: 10px !important;
  }

  .bubble{
    max-width: 92% !important;
    border-radius: 16px !important;
  }

  .chatInput{
    position: sticky;
    bottom: calc(var(--navH) + var(--safeBottom));
    z-index: 20;
    padding: 10px !important;
    gap: 8px !important;
    background: rgba(0,0,0,.20);
    backdrop-filter: blur(10px);
  }

  .chatInput input{
    min-height: 46px;
  }

  /* Neue Nachrichten Button: nicht unter Bottom-Nav verschwinden */
  #newMsgBtn{
    bottom: calc(var(--navH) + var(--safeBottom) + 16px) !important;
    right: 12px !important;
    border-radius: 14px !important;
  }

  /* ---------- Bottom Nav: klarer & konsistenter ---------- */
  #mobileBottomNav{
    display: flex !important;
    height: 64px;
    padding: 8px 10px;
  }

  #mobileBottomNav .mbtn{
    min-width: 56px;
    border-radius: 14px;
    padding: 6px 4px;
    font-size: 11px;
  }

  #mobileBottomNav .mbtn span{
    font-size: 18px;
    line-height: 1;
  }

  /* ---------- Optional: Chips etwas gr√∂√üer ---------- */
  .chip{
    padding: 5px 10px;
    font-size: 11.5px;
  }
}




/* ===== DRIVE-ONLY MODE (Infos/Dokumente) ===== */
#fileGrid{ display:none !important; }
.mainHeader{ display:none !important; }

/* Make the drive box look like a normal content panel (no dashed upload look) */
#dropzone{
  border: 1px solid var(--border) !important;
  background: rgba(0,0,0,.14) !important;
  border-radius: 16px !important;
  margin: 14px !important;
  text-align: left !important;
}
#dropzone.drag{
  /* no special drag styling */
  background: rgba(0,0,0,.14) !important;
  border-color: var(--border) !important;
  color: var(--text) !important;
}


/* --- Aktiv im Dienst (Infos) --- */
.active-duty-grid{display:grid;grid-template-columns:repeat(4,minmax(0,1fr));gap:12px;margin-top:12px}
.active-duty-item{display:flex;flex-direction:column;align-items:center;gap:8px;padding:10px;border-radius:14px;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.07)}
.active-duty-avatar{width:56px;height:56px;border-radius:50%;object-fit:cover;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.10)}
.active-duty-name{font-size:12px;color:var(--text);text-align:center;max-width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.active-duty-empty{margin-top:10px;color:var(--muted);font-size:13px}


/* SecuriReport Link wie Button ‚Äì ohne Unterstrich */
.securireport-link,
.securireport-link:visited,
.securireport-link:hover,
.securireport-link:active {
  text-decoration: none !important;
  color: var(--text);
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.securireport-link:hover {
  filter: brightness(1.08);
}


/* FINAL FIX: absolut kein Unterstrich f√ºr SecuriReport */
.securireport-link,
.securireport-link *,
.securireport-link:visited,
.securireport-link:hover,
.securireport-link:active {
  text-decoration: none !important;
}

/* Falls der Button ein <button>-Style erbt */
.securireport-link.btn,
.securireport-link.btn * {
  text-decoration: none !important;
}


    /* --- Chat Unread Badge --- */
    .hasBadge{ position:relative; }
    .tabBadge{
      position:absolute;
      top:2px;
      right:6px;
      width:12px;
      height:12px;
      padding:0;
      border-radius:999px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:4px;
      font-weight:600;
      line-height:12px; transform:scale(0.8); transform-origin:center;
      background: var(--bad);
      color:#fff;
      box-shadow: 0 2px 6px rgba(0,0,0,.35);
      pointer-events:none;
    }
    .tabBadge.hidden{ display:none !important; }

</style>

<!-- ===== MOBILE VISIBILITY FIX (Chat + Settings) ===== -->
<style>
@media (max-width: 900px){
  /* Allow JS-controlled views to appear even if earlier CSS hid them */
  .sidebar[style*="display: flex"],
  .rightbar[style*="display: flex"],
  .main[style*="display: flex"]{
    display: flex !important;
  }
}
</style>



<!-- ===== CHAT FINAL CLEAN (WhatsApp/Signal-ish + Swipe) ===== -->
<style>
/* Chat layout polish (all sizes) */
.chatLog{
  display:flex;
  flex-direction:column;
  gap:10px;
}
.bubble{
  align-self:flex-start;
  max-width:min(86%, 520px);
  padding:10px 12px;
  border-radius:16px;
  position:relative;
  word-wrap:break-word;
  overflow-wrap:anywhere;
}
.bubble.me{
  align-self:flex-end;
}
/* Meta line like WA: small, right-aligned */
.bubble .t{
  display:flex;
  justify-content:flex-end;
  gap:6px;
  font-size:11px;
  opacity:.85;
  margin-top:6px;
}
/* Optional name for others */
.bubble .u{
  font-weight:600;
  font-size:12px;
  opacity:.9;
  margin-bottom:4px;
}
/* Date separator */
.dateSep{
  align-self:center;
  font-size:11px;
  opacity:.75;
  margin:6px 0;
}

/* Swipe hint background */
.chatSwipeBg{
  position:relative;
}
.chatSwipeBg::before{
  content:"üóëÔ∏è L√∂schen";
  position:absolute;
  right:14px;
  top:50%;
  transform:translateY(-50%);
  font-size:12px;
  opacity:.0;
  transition:opacity .12s ease;
  pointer-events:none;
}
.chatSwipeBg.showDel::before{ opacity:.7; }

@media (max-width: 900px){
  /* Input row: input grows, button compact */
  .chatInput{
    display:flex !important;
    align-items:center !important;
    gap:10px !important;
  }
  .chatInput input{
    flex: 1 1 auto !important;
    min-width: 0 !important;
    min-height: 46px;
  }
  .chatInput .btn{
    width:auto !important;
    min-width: 96px;
    padding: 12px 14px !important;
    min-height: 46px;
  }

  .chatLog{ padding: 10px !important; }
  .bubble{ max-width: 88% !important; border-radius: 18px !important; }
}
</style>


<!-- ===== CHAT INPUT BAR FIX (Mobile) ===== -->
<style>
@media (max-width: 900px){
  /* The viewport already has padding-bottom for the bottom nav.
     Keep the input bar inside the chat card at the real bottom (no extra offset). */
  .rightbar .chat{
    display:flex !important;
    flex-direction:column !important;
    min-height:0 !important;
  }
  .rightbar .chatLog{
    flex:1 1 auto !important;
    min-height:0 !important;
    overflow:auto !important;
    /* Space so last messages are not hidden behind the input bar */
    padding-bottom: 84px !important;
  }

  .rightbar .chatInput{
    position: sticky !important;
    bottom: 0 !important;           /* was bottom: calc(navH + safeArea) */
    z-index: 30 !important;
    margin: 0 !important;
    border-top: 1px solid var(--border);
    background: rgba(10,14,28,.88) !important;
    backdrop-filter: blur(10px);
  }

  /* Keep button compact and input wide */
  .rightbar .chatInput input{ flex:1 1 auto !important; min-width:0 !important; }
  .rightbar .chatInput .btn{ width:auto !important; min-width: 96px; }

  /* Make sure the chat card itself can shrink/scroll properly */
  .rightbar.card, .rightbar{
    min-height:0 !important;
  }
}
</style>


<!-- ===== CHAT BUBBLES LEFT/RIGHT FIX ===== -->
<style>
/* Wrapper controls alignment for each row */
.chatSwipeBg{
  display:flex;
  justify-content:flex-start;
  width:100%;
}
.chatSwipeBg.me{
  justify-content:flex-end;
}

/* Keep delete hint aligned to the swipe direction (left swipe shows on right) */
.chatSwipeBg::before{
  right: 14px;
}
</style>



<!-- ===== MOBILE KEYBOARD / JUMP FIX (Chat) ===== -->
<style>
@media (max-width: 900px){
  :root{ --kb: 0px; } /* keyboard offset set by JS */

  /* Keep outer viewport stable; let chatLog scroll (only while chat is visible) */
  .rightbar[style*="display: flex"] ~ .viewport,
  .rightbar[style*="display:flex"] ~ .viewport{ /* (fallback if markup changes) */
    overflow: hidden !important;
  }

  /* Apply ONLY when chat panel (rightbar) is visible */
  .rightbar[style*="display: flex"],
  .rightbar[style*="display:flex"]{
    height: calc(100dvh - 16px) !important;
    min-height: 0 !important;
  }

  .rightbar[style*="display: flex"] .chat,
  .rightbar[style*="display:flex"] .chat{
    display:flex !important;
    flex-direction:column !important;
    flex: 1 1 auto !important;
    min-height: 0 !important;
  }

  .rightbar[style*="display: flex"] .chatLog,
  .rightbar[style*="display:flex"] .chatLog{
    flex: 1 1 auto !important;
    min-height: 0 !important;
    overflow: auto !important;
    padding-bottom: calc(78px + var(--navH) + var(--safeBottom) + var(--kb)) !important;
  }

  /* Input fixed above bottom nav + keyboard ONLY when chat visible */
  .rightbar[style*="display: flex"] .chatInput,
  .rightbar[style*="display:flex"] .chatInput{
    position: fixed !important;
    left: 14px !important;
    right: 14px !important;
    bottom: calc(var(--navH) + var(--safeBottom) + var(--kb)) !important;
    z-index: 60 !important;
    border: 1px solid var(--border) !important;
    border-radius: 16px !important;
    box-shadow: var(--shadow);
    margin: 0 !important;
  }

  .rightbar[style*="display: flex"].card,
  .rightbar[style*="display:flex"].card{
    padding-bottom: calc(86px + var(--navH) + var(--safeBottom)) !important;
  }
}
</style>




<!-- ===== CHAT: ONLY MESSAGE LIST SCROLLS (scoped) ===== -->
<style>
@media (max-width: 900px){
  /* Default (all tabs): allow normal scroll */
  html, body{ height:auto; overflow:auto; }
  .viewport{ overflow:auto; height: 100dvh; }

  /* CHAT active: lock everything except .chatLog */
  body.view-chat{
    height: 100%;
    overflow: hidden !important;
  }
  body.view-chat .viewport{
    height: 100dvh !important;
    overflow: hidden !important;
    /* reserve space for bottom nav, without creating scroll */
    padding-bottom: 0 !important;
    }

  /* Chat panel occupies the remaining height above bottom nav */

    display: flex !important;
    flex-direction: column !important;
    height: calc(100dvh - var(--navH) - var(--safeBottom)) !important;
    min-height: 0 !important;
    overflow: hidden !important; /* prevent chat tab scrolling */
    margin: 0 !important;
  }

  body.view-chat .rightbar .chat{
    flex: 1 1 auto !important;
    min-height: 0 !important;
    display:flex !important;
    flex-direction: column !important;
    overflow: hidden !important; /* prevent nested scroll */
  }

  /* Only the message list scrolls */
  body.view-chat .rightbar .chatLog{
    flex: 1 1 auto !important;
    min-height: 0 !important;
    overflow-y: auto !important;
    overflow-x: hidden !important;
    overscroll-behavior: contain;
    -webkit-overflow-scrolling: touch;
    padding-bottom: 8px !important;
  }

  /* Input bar stays visible at bottom of chat card */
  body.view-chat .rightbar .chatInput{
    flex: 0 0 auto !important;
    position: sticky !important;
    bottom: 0 !important;
    z-index: 50 !important;
    margin: 0 !important;
    border-top: 1px solid var(--border);
    background: rgba(10,14,28,.90) !important;
    backdrop-filter: blur(10px);
  }
}
</style>


<!-- ===== CHAT FIT FIX (no content behind input) ===== -->
<style>
@media (max-width: 900px){
  :root{ --chatInputH: 72px; }

  /* In chat view: rightbar fills space ABOVE bottom nav */

    height: calc(100dvh - var(--navH) - var(--safeBottom)) !important;
    max-height: calc(100dvh - var(--navH) - var(--safeBottom)) !important;
  }

  /* Make sure containers don't create extra scroll */
  body.view-chat .rightbar,
  body.view-chat .rightbar .chat{
    overflow: hidden !important;
  }

  /* Only chatLog scrolls, and it reserves space for the input bar */
  body.view-chat .rightbar .chatLog{
    padding-bottom: calc(var(--chatInputH) + 12px) !important;
    box-sizing: border-box;
  }

  /* Keep input stuck to bottom INSIDE the card (not covering content) */
  body.view-chat .rightbar .chatInput{
    position: sticky !important;
    bottom: 0 !important;
    margin-top: 0 !important;
  }
}
</style>



<!-- ===== MOBILE HEADBAR / LAYOUT: hide side columns except their tab ===== -->
<style>
@media (max-width: 900px){
  /* Single column base */
  .app{
    grid-template-columns: 1fr !important;
  }
  .main{
    grid-column: 1 / -1 !important;
    width: 100% !important;
    min-width: 0 !important;
  }

  /* Strictly hide side columns on mobile */
  .sidebar{ display:none !important; }
  .rightbar{ display:none !important; }

  /* Only show when their tab is active */
  body.view-settings .sidebar{ display:flex !important; }


  /* Headbar for main panels */
  #startPanel .topbar,
  #rankingPanel .topbar,
  #casePanel .topbar{
    position: sticky;
    top: 0;
    z-index: 20;
    background: rgba(10,14,28,.80);
    backdrop-filter: blur(10px);
  }

  /* Make these panels always full width */
  #startPanel, #rankingPanel, #casePanel{
    width: 100% !important;
    margin: 6px 4px !important;
  }
}
</style>


<!-- ===== FINAL MOBILE VIEW OVERRIDES (fix side columns) ===== -->
<style>
@media (max-width: 900px){
  .app{ grid-template-columns: 1fr !important; }
  .main{ grid-column: 1 / -1 !important; width:100% !important; }

  /* default: no side columns */
  .sidebar, .rightbar{ display:none !important; }

  /* only show in their dedicated view */
  body.view-settings .sidebar{ display:flex !important; }

}
</style>


<!-- ===== MOBILE START/RANK/FALL INTERNAL LAYOUT FIX ===== -->
<style>
@media (max-width: 900px){

  /* START PANEL: collapse internal layout into vertical flow */
  #startPanel .section{
    display: block !important;
  }

  #startPanel .section > div{
    width: 100% !important;
    max-width: 100% !important;
  }

  /* Menu buttons stacked */
  #startPanel .row2{
    display: grid !important;
    grid-template-columns: 1fr !important;
    gap: 10px !important;
  }

  /* RANK + FALL panels */
  #rankingPanel .section,
  #casePanel .section{
    display: block !important;
  }

  #rankingPanel .section > *,
  #casePanel .section > *{
    width: 100% !important;
    max-width: 100% !important;
  }
}
</style>


<!-- ===== DRIVE MODE: disable local upload UI ===== -->
<style>
/* Hide local upload controls if they exist anywhere */
#filePicker, #btnPickFiles{ display:none !important; }
</style>


<style>
/* This keeps the layout, but disables drag interactions */
#dropzone{ user-select:none; }
</style>

<style>


/* ===== PANEL LAYOUT FIX: topbar should be TOP (not left) =====
   Because JS sets panels to display:flex, they default to flex-direction:row.
   Force column layout so content uses full width. */
#startPanel, #rankingPanel, #casePanel{
  flex-direction: column !important;
  align-items: stretch !important;
}
#startPanel .topbar, #rankingPanel .topbar, #casePanel .topbar{
  width: 100% !important;
}

</style>
<style>

/* ===== CASE LIST ("Deine F√§lle") ‚Äì better mobile layout ===== */
#caseList .item{
  align-items: center !important;
  gap: 12px !important;
}
#caseList .btn{
  width: auto !important;          /* override mobile .btn { width:100% } */
  min-width: 44px !important;
  min-height: 44px !important;
  padding: 10px 12px !important;
}
#caseList .caseMeta{
  flex: 1 1 auto !important;
  min-width: 0 !important;
}
#caseList .caseTitle{
  font-weight: 900;
  font-size: 14px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
#caseList .caseSub{
  font-size: 12px;
  color: var(--muted);
  margin-top: 2px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

</style>
<style>

/* ===== MOBILE: Presence (Online + Avatars) in Start + Chat ===== */
@media (max-width: 900px){
  #presenceBarStartMobile, #presenceBarChatMobile{
    padding-left: 0;
    gap: 6px;
  }
  #presenceBarStartMobile .presenceLabel,
  #presenceBarChatMobile .presenceLabel{
    font-size: 11px;
  }
  #presenceBarStartMobile .avatar,
  #presenceBarChatMobile .avatar{
    width: 26px;
    height: 26px;
    margin-left: -7px;
  }
  #presenceBarStartMobile .avatar:first-child,
  #presenceBarChatMobile .avatar:first-child{
    margin-left: 0;
  }
}

</style>

<!-- ===== HOME: Services List readability + smaller delete button ===== -->
<style>
/* "Erfasste Dienste" ‚Äì better readability + compact delete */
#serviceList{ padding: 0 !important; }
#serviceList .item{
  align-items: flex-start !important;
  gap: 12px !important;
}
#serviceList .meta{ min-width:0; }
#serviceList .title{
  font-size: 14px;
  line-height: 1.25;
  white-space: normal !important;
  overflow: visible !important;
  text-overflow: clip !important;
}
#serviceList .desc{
  font-size: 12.5px;
  line-height: 1.35;
  white-space: normal !important;
  overflow: visible !important;
  text-overflow: clip !important;
  margin-top: 4px;
}
/* Keep delete button small even on mobile (overrides .btn{width:100%} mobile rule) */
#serviceList button.btn{
  width: auto !important;
  min-width: 40px !important;
  min-height: 40px !important;
  padding: 8px 10px !important;
  border-radius: 12px !important;
  font-size: 13px !important;
}
#serviceList button.btn.danger{
  background: rgba(255,77,109,.10) !important;
  border-color: rgba(255,77,109,.30) !important;
}
</style>


<!-- ===== MOBILE REFACTOR (clean + single scroll owner) ===== -->
<style id="mobile-refactor">
/* Goals:
   - No outer (body/html) scrolling on mobile
   - Exactly one visible panel at a time
   - Panel scroll (not the page); in Chat ONLY message list scrolls
   - Works even if JS toggles via inline styles OR via body classes
*/
@media (max-width: 900px){

  /* Lock the page itself */
  html, body{
    height: 100% !important;
    width: 100% !important;
    overflow: hidden !important;
    position: fixed !important;
    inset: 0 !important;
    overscroll-behavior: none !important;
  }

  /* One fixed viewport; NO scrolling here */
  .viewport{
    position: fixed !important;
    inset: 0 !important;
    height: 100dvh !important;
    overflow: hidden !important;
    padding: 0 !important;
  }

  :root{ --navH: 72px; } /* keep consistent */

  /* App shell stays within the screen above bottom nav */
  .app{
    height: calc(100dvh - var(--navH) - var(--safeBottom)) !important;
    max-height: calc(100dvh - var(--navH) - var(--safeBottom)) !important;
    min-height: 0 !important;
    overflow: hidden !important;
    padding: 8px !important;
    gap: 10px !important;
  }

  /* Default: hide all panels (we will enable exactly one) */
  .sidebar, .main, .rightbar,
  #startPanel, #rankingPanel, #casePanel{
    display: none !important;
    min-height: 0 !important;
    height: 100% !important;
  }

  /* --- Visibility (body classes) --- */
  body.view-start #startPanel{ display:flex !important; flex-direction:column !important; }
  body.view-files .main{ display:flex !important; flex-direction:column !important; }
  body.view-case #casePanel{ display:flex !important; flex-direction:column !important; }

  body.view-settings .sidebar{ display:flex !important; flex-direction:column !important; }

  /* Ranking can be either view-rank or view-ranking (some scripts use different names) */
  body.view-rank #rankingPanel,
  body.view-ranking #rankingPanel{
    display:flex !important;
    flex-direction:column !important;
  }

  /* --- Visibility fallback (inline styles set by JS) ---
     Your JS sets start/ranking/case panels via element.style.display="flex".
     Because we use !important above, we must explicitly allow it. */
  #startPanel[style*="display: flex"]{ display:flex !important; flex-direction:column !important; }
  #rankingPanel[style*="display: flex"]{ display:flex !important; flex-direction:column !important; }
  #casePanel[style*="display: flex"]{ display:flex !important; flex-direction:column !important; }
  .sidebar[style*="display: flex"]{ display:flex !important; flex-direction:column !important; }
  .main[style*="display: flex"]{ display:flex !important; flex-direction:column !important; }
  .rightbar[style*="display: flex"]{ display:flex !important; flex-direction:column !important; }

  /* --- Scrolling rules --- */

  /* Non-chat panels scroll as a whole (header can be sticky inside if you use it) */
  body.view-start #startPanel,
  body.view-files .main,
  body.view-case #casePanel,
  body.view-settings .sidebar,
  body.view-rank #rankingPanel,
  body.view-ranking #rankingPanel,
  #startPanel[style*="display: flex"],
  #rankingPanel[style*="display: flex"],
  #casePanel[style*="display: flex"]{
    overflow-y: auto !important;
    -webkit-overflow-scrolling: touch;
    overscroll-behavior: contain;
  }

  /* Chat: ONLY chatLog scrolls */
  body.view-chat .rightbar,
  .rightbar[style*="display: flex"]{
    overflow: hidden !important;
  }
  body.view-chat .rightbar .chat,
  .rightbar[style*="display: flex"] .chat{
    display:flex !important;
    flex-direction: column !important;
    flex: 1 1 auto !important;
    min-height: 0 !important;
    overflow: hidden !important;
  }
  body.view-chat .rightbar .chatLog,
  .rightbar[style*="display: flex"] .chatLog{
    flex: 1 1 auto !important;
    min-height: 0 !important;
    overflow-y: auto !important;
    overflow-x: hidden !important;
    overscroll-behavior: contain;
    -webkit-overflow-scrolling: touch;
  }
  body.view-chat .rightbar .chatInput,
  .rightbar[style*="display: flex"] .chatInput{
    flex: 0 0 auto !important;
    position: sticky !important;
    bottom: 0 !important;
    z-index: 60 !important;
  }


  /* --- Force chat input to sit at the bottom of the chat card (override older fixed/floating rules) --- */
  body.view-chat .rightbar .chatInput,
  .rightbar[style*="display: flex"] .chatInput{
    position: sticky !important;
    left: auto !important;
    right: auto !important;
    bottom: 0 !important;
    margin: 0 !important;
    border-radius: 0 0 16px 16px !important; /* attached, not floating */
    box-shadow: none !important;
  }

  /* Some older blocks add padding-bottom to the whole rightbar/card -> remove so input isn't "floating" */
  body.view-chat .rightbar.card,

    padding-bottom: 0 !important;
    margin-bottom: 0 !important;
  }


  /* Reserve space for chat input so last message isn't hidden */
  :root{ --chatInputH: 72px; }
  body.view-chat .rightbar .chatLog,
  .rightbar[style*="display: flex"] .chatLog{
    padding-bottom: calc(var(--chatInputH) + 12px) !important;
  }

  /* Allow vertical pan only where it should scroll */
  body{ touch-action: none; }
  body.view-chat .chatLog,
  body.view-start #startPanel,
  body.view-files .main,
  body.view-case #casePanel,
  body.view-settings .sidebar,
  body.view-rank #rankingPanel,
  body.view-ranking #rankingPanel,
  .list, .grid{
    touch-action: pan-y;
  }


  /* --- CHAT: hard-pin input to bottom of the chat panel (beats older fixed/sticky rules) --- */
  body.view-chat .rightbar,
  .rightbar[style*="display: flex"]{
    position: relative !important;
    height: 100% !important;
    overflow: hidden !important;
  }

  /* Ensure chat container fills panel */
  body.view-chat .rightbar .chat,
  .rightbar[style*="display: flex"] .chat{
    position: relative !important;
    height: 100% !important;
    flex: 1 1 auto !important;
    overflow: hidden !important;
  }

  /* Pin input absolutely to the bottom INSIDE the card */
  body.view-chat .rightbar .chatInput,
  .rightbar[style*="display: flex"] .chatInput{
    position: absolute !important;
    left: 0 !important;
    right: 0 !important;
    bottom: 0 !important;
    margin: 0 !important;
    border-radius: 0 0 16px 16px !important;
    box-shadow: none !important;
  }

  /* Make the message list the only scroll area and reserve space for the pinned input */
  body.view-chat .rightbar .chatLog,
  .rightbar[style*="display: flex"] .chatLog{
    overflow-y: auto !important;
    padding-bottom: calc(var(--chatInputH) + 14px) !important;
  }



  /* --- Active panel should fill the app viewport (grid can otherwise size by content) --- */
  .app{ position: relative !important; }

  body.view-start #startPanel,
  body.view-files .main,
  body.view-case #casePanel,
  body.view-chat .rightbar,
  body.view-settings .sidebar,
  body.view-rank #rankingPanel,
  body.view-ranking #rankingPanel,
  #startPanel[style*="display: flex"],
  #rankingPanel[style*="display: flex"],
  #casePanel[style*="display: flex"],
  .sidebar[style*="display: flex"],
  .main[style*="display: flex"],
  .rightbar[style*="display: flex"]{
    position: absolute !important;
    inset: 0 !important;
    /* keep your card spacing inside the app */
    margin: 6px 4px !important;
    height: auto !important;
    max-height: none !important;
  }

  /* With absolute panels, ensure the chat input pins to the real bottom */
  body.view-chat .rightbar .chat,
  .rightbar[style*="display: flex"] .chat{
    height: 100% !important;
  }



  /* --- CHAT: make chat area fill remaining height; input sits at true bottom via flex (no floating) --- */
  body.view-chat .rightbar,
  .rightbar[style*="display: flex"]{
    display: flex !important;
    flex-direction: column !important;
    height: 100% !important;
    overflow: hidden !important;
  }

  /* Hints above chat take natural height; chat fills the rest */
  body.view-chat .rightbar .chat,
  .rightbar[style*="display: flex"] .chat{
    display: flex !important;
    flex-direction: column !important;
    flex: 1 1 auto !important;
    min-height: 0 !important;
    overflow: hidden !important;
  }

  body.view-chat .rightbar .chatLog,
  .rightbar[style*="display: flex"] .chatLog{
    flex: 1 1 auto !important;
    min-height: 0 !important;
    overflow-y: auto !important;
    padding-bottom: 12px !important;
    -webkit-overflow-scrolling: touch;
    overscroll-behavior: contain;
  }

  body.view-chat .rightbar .chatInput,
  .rightbar[style*="display: flex"] .chatInput{
    flex: 0 0 auto !important;
    position: static !important;   /* kill absolute/sticky/fixed */
    left: auto !important;
    right: auto !important;
    bottom: auto !important;
    margin-top: auto !important;   /* pushes it to the bottom */
    width: 100% !important;
    border-radius: 0 0 16px 16px !important;
    box-shadow: none !important;
  }



  /* --- Kill legacy bottom padding that creates "empty space" below chat input --- */
  body.view-chat .rightbar.card,
  body.view-chat aside.rightbar.card,
  .rightbar.card[style*="display: flex"],
  .rightbar.card[style*="display:flex"],
  .rightbar[style*="display: flex"].card,
  .rightbar[style*="display:flex"].card{
    padding-bottom: 0 !important;
  }

}
</style>


<style id="settings-scroll-fix">
/* Fix: Settings screen must be scrollable on mobile (body is sometimes locked to avoid outer scroll) */
@media (max-width: 980px){
  body.view-settings { overflow: hidden; }
  /* allow the visible panel to scroll */
  body.view-settings .viewport,
  body.view-settings .app,
  body.view-settings .sidebar {
    overflow-y: auto !important;
    -webkit-overflow-scrolling: touch;
  }
  /* ensure sidebar has a scrollable height above bottom nav */
  body.view-settings .sidebar{
    max-height: calc(100dvh - var(--mobile-header-h, 0px) - var(--bottom-nav-h, 86px) - env(safe-area-inset-bottom) - 16px) !important;
    touch-action: pan-y;
    overscroll-behavior: contain;
    padding-bottom: calc(env(safe-area-inset-bottom) + 12px) !important;
  }
}
</style>


<style>
.securireport-card{
  margin-top:16px;
  padding:16px;
  border-radius:16px;
  background:linear-gradient(160deg,#1e2a44,#0f1628);
  box-shadow:0 10px 30px rgba(0,0,0,.35);
  text-align:center;
}
.securireport-card .card-header{
  display:flex;
  justify-content:center;
  align-items:center;
  gap:10px;
  font-size:18px;
  font-weight:600;
  margin-bottom:8px;
}
.securireport-card .icon{font-size:22px;}
.securireport-card .card-text{
  font-size:14px;
  opacity:.9;
  margin-bottom:14px;
}
.securireport-btn{
  display:inline-block;
  padding:12px 18px;
  border-radius:999px;
  background:linear-gradient(135deg,#4f8cff,#6aa7ff);
  color:#fff;
  text-decoration:none;
  font-weight:600;
}
.securireport-btn:active{transform:scale(.97);}
</style>


<style>
/* ===== UI polish: clearer navigation labels ===== */
.drawerBtn{ text-align:left; }
.drawerBtn.active{ box-shadow: inset 0 0 0 1px rgba(93,214,255,.35); }

/* ===== Infos (Main) quick link row ===== */
#activeDutyZone .row2{ gap: 10px; }
#activeDutyZone #btnOpenSecuriReport{ min-width: 220px; }
@media (max-width:900px){
  #activeDutyZone #btnOpenSecuriReport{ width: 100%; min-width: 0; }
}
</style>


<style>
.drawerDivider{height:1px;background:rgba(255,255,255,.12);margin:10px 0;}
</style>

<style>
/* ===== DELINQUENTEN MOBILE LIST V1 ===== */
#delinqList .delinqItem{
  display:flex;
  gap:10px;
  align-items:flex-start;
  justify-content:space-between;
  padding:10px 12px;
  border:1px solid rgba(255,255,255,.10);
  border-radius:14px;
  background: rgba(0,0,0,.10);
}
#delinqList .delinqMeta{ flex:1 1 auto; min-width:0; }
#delinqList .delinqTitle{
  font-weight:900;
  font-size:14px;
  line-height:1.25;
  white-space:normal;
}
#delinqList .delinqSub{
  margin-top:4px;
  font-size:12px;
  line-height:1.35;
  color:var(--muted);
  white-space:normal;
  word-break:break-word;
}
#delinqList .delinqActions{
  display:flex;
  gap:8px;
  flex:0 0 auto;
}
#delinqList .delinqActions .btn{
  width:auto !important;
  min-width:44px !important;
  min-height:44px !important;
  padding:10px 12px !important;
  border-radius:14px !important;
}
@media (max-width: 900px){
  #delinqList .delinqActions{ flex-direction:column; }
}
</style>

<style id="mobileChatComposerOverlay">
@media (max-width: 980px){
  #mobileChatComposer{
    position: fixed;
    left: 12px;
    right: 12px;
    bottom: calc(var(--navH, 72px) + env(safe-area-inset-bottom, 0px) + 10px);
    z-index: 99999;
    display: none; /* only visible in chat view */
    gap: 10px;
    padding: 10px;
    border: 1px solid rgba(255,255,255,.10);
    border-radius: 16px;
    background: rgba(10,14,28,.92);
    backdrop-filter: blur(10px);
    box-shadow: 0 14px 40px rgba(0,0,0,.45);
  }
  #mobileChatComposer input{
    flex: 1 1 auto;
    min-width: 0;
    min-height: 46px;
  }
  #mobileChatComposer button{
    min-width: 96px;
  }
  /* Give the chat log space so last messages aren't hidden behind composer */
  body.view-chat #chatLog{
    padding-bottom: calc(140px + var(--navH, 72px) + env(safe-area-inset-bottom, 0px)) !important;
  }
}
@media (min-width: 981px){
  #mobileChatComposer{ display:none !important; }
}
</style>


<script id="mobileChatComposerOverlayJs">
(function(){
  function isMobile(){ return window.matchMedia && window.matchMedia("(max-width: 980px)").matches; }
  function inChat(){
    // primary: body class used by this app
    if(document.body.classList.contains("view-chat")) return true;
    // fallback: active button id/class
    const active = document.querySelector(".tabBtn.active, .mbtn.active, #mobileBottomNav .mbtn.active");
    const id = active?.id || "";
    return /chat/i.test(id);
  }

  function ensure(){
    let bar = document.getElementById("mobileChatComposer");
    if(bar) return bar;

    bar = document.createElement("div");
    bar.id = "mobileChatComposer";

    const inp = document.createElement("input");
    inp.id = "chatTextMobile";
    inp.placeholder = "Nachricht eingeben‚Ä¶";
    inp.autocomplete = "off";

    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "btn primary";
    btn.textContent = "Senden";

    const send = ()=>{
      const v = (inp.value || "").trim();
      if(!v) return;
      const desktopInp = document.getElementById("chatText");
      if(desktopInp) desktopInp.value = v;
      const desktopBtn = document.getElementById("btnSend");
      if(desktopBtn) desktopBtn.click();
      else if(typeof window.sendChat === "function") window.sendChat();
      inp.value = "";
    };

    btn.addEventListener("click", send);
    inp.addEventListener("keydown", (e)=>{
      if(e.key === "Enter"){
        e.preventDefault();
        send();
      }
    });

    bar.appendChild(inp);
    bar.appendChild(btn);
    document.body.appendChild(bar);
    return bar;
  }

  function sync(){
    const bar = document.getElementById("mobileChatComposer");
    // If not mobile, ensure hidden (and don't create)
    if(!isMobile()){
      if(bar) bar.style.display = "none";
      return;
    }
    const b = bar || ensure();
    b.style.display = (inChat() ? "flex" : "none");
  }

  // Run ASAP (no timeout delay)
  if(document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", sync, { once:true });
  }else{
    sync();
  }
  window.addEventListener("resize", sync);

  // 1) Observe body class changes (instant show/hide on view switch)
  try{
    const mo = new MutationObserver(()=> sync());
    mo.observe(document.body, { attributes:true, attributeFilter:["class"] });
  }catch(_){}

  // 2) Hook navigation clicks for immediate UI feedback
  function bindNavClicks(){
    const navBtns = document.querySelectorAll(".tabBtn, #mobileBottomNav .mbtn, .mbtn");
    navBtns.forEach(btn=>{
      btn.addEventListener("click", ()=>{
        // run on next microtask (after app updates classes)
        Promise.resolve().then(sync);
      }, { passive:true });
    });
  }
  if(document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", bindNavClicks, { once:true });
  }else{
    bindNavClicks();
  }

  // 3) Wrap view-setter functions (if present) without delay
  const wrap = (fnName)=>{
    const orig = window[fnName];
    if(typeof orig !== "function") return;
    window[fnName] = function(){
      const r = orig.apply(this, arguments);
      sync();
      return r;
    };
  };
  wrap("setView");
  wrap("setMobileView");
})();
</script>



<style id="tabBadgeAutoWidth">
  .tabBadge:not(.hidden):not(:empty){
    /* keep small, but allow 2+ chars if needed */
    min-width: 12px;
  }
  .tabBadge:not(.hidden):not(:empty)[data-len="2"],
  .tabBadge:not(.hidden):not(:empty)[data-len="3"]{
    width:auto;
    min-width:14px;
    padding:0 2px;
  }
</style>
<script id="tabBadgeLen">
(function(){
  const ids=["badgeNavChat","badgeDnavChat","badgeMbChat"];
  const tick=()=>{
    ids.forEach(id=>{
      const el=document.getElementById(id);
      if(!el) return;
      const t=(el.textContent||"").trim();
      el.setAttribute("data-len", String(t.length));
    });
  };
  setInterval(tick, 300);
})();
</script>


<style id="delinqCasesDetails">
  .delinqCases{ margin-top:8px; }
  .delinqCases summary{
    list-style:none;
    cursor:pointer;
    user-select:none;
    font-size:12px;
    opacity:.9;
  }
  .delinqCases summary::-webkit-details-marker{ display:none; }
  .delinqCasesList{
    margin-top:8px;
    display:flex;
    flex-direction:column;
    gap:6px;
  }
  .delinqCaseRow{
    font-size:12px;
    opacity:.95;
    padding:6px 8px;
    border:1px solid rgba(255,255,255,.08);
    border-radius:12px;
    background: rgba(255,255,255,.03);
  }
</style>

</head>
<body>
<div id="authOverlay" class="authOverlay">
  <div class="card authModal">
    <div class="authTitle" id="authTitle">Login / Registrierung</div>
    <div class="field">
      <label>Benutzername</label>
      <input id="authUser" placeholder="Hier deine E-Mail eingeben" autocomplete="username"/>
    </div>
    <div class="field">
      <label>Passwort</label>
      <input id="authPass" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" type="password" autocomplete="current-password"/>
    </div>
    <div class="row2" style="margin-top:10px;">
      <button class="btn primary" id="btnDoLogin" type="button">Login</button>
</div>
</div>
</div>
<div id="adminOverlay" class="authOverlay hidden">
  <div class="card authModal adminModal">
    <div class="adminHeader">
      <div class="authTitle" style="margin:0;">Admin Bereich</div>
      <button class="btn small" id="btnCloseAdmin" type="button">Schlie√üen</button>
    </div>

    <div class="adminLayout">
      <nav class="adminNav" id="adminNav" aria-label="Admin Navigation">
        <button class="adminNavBtn active" type="button" data-admin-tab="access">üîê Zugang</button>
        <button class="adminNavBtn" type="button" data-admin-tab="roles">üß© Rollen</button>
        <button class="adminNavBtn" type="button" data-admin-tab="chat">üí¨ Chat</button>
      </nav>

      <div class="adminContent">
        <!-- Zugang -->
        <section class="adminPage" data-admin-page="access">
          <div class="adminCard">
            <div class="adminCardTitle">App Whitelist</div>
            <div class="hint" style="margin-top:6px;">Zugelassene E-Mails (eine pro Zeile). Alles wird klein geschrieben gespeichert.</div>
            <textarea id="whitelistBox" class="adminTextarea"></textarea>
            <div class="row2" style="margin-top:10px;">
              <button class="btn primary" id="btnSaveWhitelist" type="button">Whitelist speichern</button>
              <div></div>
            </div>
          </div>
        </section>

        <!-- Rollen -->
        <section class="adminPage hidden" data-admin-page="roles">
          <div class="adminGrid2">
            <div class="adminCard">
              <div class="adminCardTitle">Rolle anlegen / √§ndern</div>
              <div class="hint" style="margin-top:6px;">Name + Rechte setzen, dann speichern.</div>

              <div class="field">
                <label>Rollenname</label>
                <input id="roleName" placeholder="z.B. Leitung oder Mitarbeiter"/>
              </div>

              <div class="row2">
                <label class="pill"><input type="checkbox" id="roleCanUpload"/> Upload</label>
                <label class="pill"><input type="checkbox" id="roleCanDownload"/> Download</label>
              </div>
              <div class="row2" style="margin-top:8px;">
                <label class="pill"><input type="checkbox" id="roleCanAdmin"/> Admin</label>
                <div></div>
              </div>

              <div class="row2" style="margin-top:10px;">
                <button class="btn primary" id="btnSaveRole" type="button">Rolle speichern</button>
                <button class="btn danger" id="btnDeleteRole" type="button">Rolle l√∂schen</button>
              </div>
            </div>

            <div class="adminCard">
              <div class="adminCardTitle">Benutzer Rolle zuweisen</div>

              <div class="field">
                <label>E-Mail</label>
                <input id="userRoleEmail" placeholder="user@firma.ch"/>
              </div>
              <div class="field">
                <label>Rolle</label>
                <select id="userRoleSelect"></select>
              </div>

              <div class="row2" style="margin-top:10px;">
                <button class="btn primary" id="btnSetUserRole" type="button">Rolle zuweisen</button>
                <button class="btn" id="btnRefreshRoleOverview" type="button">Aktualisieren</button>
              </div>

              <div class="divider"></div>

              <div class="adminCardTitle" style="margin-top:2px;">√úbersicht</div>
              <div class="field" style="margin-top:10px;">
                <label>Suche</label>
                <input id="roleOverviewSearch" placeholder="E-Mail oder Rolle..." />
              </div>
              <div class="hint" id="roleOverviewHint" style="margin-top:6px;">‚Äî</div>

              <div class="adminTableWrap" style="margin-top:10px;">
                <table id="roleOverviewTable" class="adminTable"></table>
              </div>
            </div>
          </div>
        </section>

        <!-- Chat -->
        <section class="adminPage hidden" data-admin-page="chat">
          <div class="adminGrid2">
            <div class="adminCard">
              <div class="adminCardTitle">Chat Rollen</div>
              <div class="hint" style="margin-top:6px;">Damit im Chat ein Admin/Moderator an einem Icon erkennbar ist.</div>

              <div class="field">
                <label>E-Mail (f√ºr Chat-Rolle)</label>
                <input id="chatRoleEmail" placeholder="user@firma.ch"/>
              </div>
              <div class="field">
                <label>Rolle</label>
                <select id="chatRoleSelect">
                  <option value="user">User</option>
                  <option value="mod">Moderator</option>
                  <option value="admin">Admin</option>
                </select>
              </div>

              <div class="row2" style="margin-top:10px;">
                <button class="btn primary" id="btnSetChatRole" type="button">Chat-Rolle speichern</button>
                <button class="btn danger" id="btnDeleteChatRole" type="button">Chat-Rolle l√∂schen</button>
              </div>

              <div class="hint" style="margin-top:12px;">Aktuelle Chat-Rollen (read-only)</div>
              <textarea id="chatRolesBox" class="adminTextarea" readonly></textarea>
            </div>

            <div class="adminCard">
              <div class="adminCardTitle">Chat Moderation</div>
              <div class="hint" style="margin-top:6px;">Nutzer muten (UIDs oder E-Mails, je Zeile) und Chat/Systemmeldungen bereinigen.</div>

              <div class="field">
                <label>Muted (eine UID oder E-Mail pro Zeile)</label>
                <textarea id="mutedBox" class="adminTextarea" style="min-height:140px;"></textarea>
              </div>

              <div class="row2" style="margin-top:10px;">
                <button class="btn primary" id="btnSaveMuted" type="button">Muted speichern</button>
                <button class="btn danger" id="btnClearChat" type="button">Chat leeren (letzte 500)</button>
              </div>
              <div class="row2" style="margin-top:10px;">
                <button class="btn danger" id="btnClearSystem" type="button">Systemmeldungen l√∂schen (letzte 500)</button>
                <div></div>
              </div>
              <div class="hint" style="margin-top:8px;">Hinweis: Mute blockiert das Senden. Lesen bleibt erlaubt.</div>
            </div>
          </div>
        </section>

      </div>
    </div>
  </div>
</div>
</div>

  </div>
</div>

<div class="mobileHeader hidden" id="mobileHeader">
  <button class="iconBtn" id="btnHamburger" type="button" aria-label="Men√º √∂ffnen">‚ò∞</button>
  <div class="mhTitle">
    <div style="font-weight:900" id="mhAppName">Projekt TAS</div>
    <div class="mhSub" id="mhDateLine"></div>
  </div>
  <div style="display:flex; gap:8px; align-items:center;">
    <div class="chip" id="mhUserChip">offline</div>
  </div>
</div>

<div id="delinqOverlay" class="authOverlay hidden">
  <div class="card authModal" style="max-width:980px; width:min(980px, 94vw);">
    <div class="adminHeader" style="margin-bottom:10px;">
      <div class="authTitle" style="margin:0;">üóÉÔ∏è Delinquenten Datenbank</div>
      <button class="btn small" id="btnCloseDelinq" type="button">Schlie√üen</button>
    </div>

    <div class="row2" style="gap:12px; align-items:flex-start; flex-wrap:wrap;">
      <div class="card" style="flex:1; min-width:280px; padding:12px;">
        <div style="font-weight:900; margin-bottom:10px;">Neuen Delinquenten erfassen</div>

        <div class="field">
          <label>Vorname</label>
          <input id="delinqFirstName" placeholder="z.B. Max" />
        </div>

        <div class="field">
          <label>Nachname</label>
          <input id="delinqLastName" placeholder="z.B. Mustermann" />
        </div>

        <div class="field">
          <label>Geburtsdatum</label>
          <input id="delinqBirthDate" type="date" />
        </div>
<div class="field" style="margin-top:8px;">
          <label style="display:flex; gap:10px; align-items:center;">
            <input id="delinqHouseBan" type="checkbox" />
            <span>Hausverbot (Ja)</span>
          </label>
        </div>

        <!-- F√§lle / Vorf√§lle pro Person (mehrere m√∂glich) -->
        <div class="card" style="margin-top:12px; padding:10px; border:1px solid rgba(255,255,255,0.08);">
          <div style="font-weight:900; margin-bottom:8px;">Fall/F√§lle (Hier eintragen)</div>

          <div class="row2" style="gap:8px;">
            <div class="field" style="margin-top:0;">
              <label>Fall Nr.</label>
              <input id="delinqCaseNo" placeholder="z.B. 1/2/3 etc." />
            </div>
            <div class="field" style="margin-top:0;">
              <label>Datum</label>
              <input id="delinqCaseDate" type="date" />
            </div>
          </div>

          <div class="field" style="margin-top:8px;">
            <label>Ort</label>
            <input id="delinqCasePlace" placeholder="z.B. Bahnhof / Filiale / Stadt" />
          </div>

          <div style="display:flex; gap:8px; margin-top:10px; align-items:center;">
            <button class="btn" id="btnAddDelinqCase" type="button">+ Fall hinzuf√ºgen</button>
            <div class="hint" style="margin:0;">F√§lle werden beim Speichern √ºbernommen.</div>
          </div>

          <div class="list" id="delinqCaseList" style="margin-top:10px; padding:0; gap:8px;"></div>
        </div>

        <div class="row2" style="margin-top:10px;">
          <button class="btn primary" id="btnSaveDelinq" type="button">Speichern</button>
          <button class="btn" id="btnClearDelinq" type="button">Leeren</button>
        </div>

        <div class="hint" style="margin-top:10px;">
          Duplikate werden automatisch verhindert.
        </div>
      </div>

      <div class="card" style="flex:1.2; min-width:320px; padding:12px;">
        <div style="font-weight:900; margin-bottom:10px;">Liste</div>

        <div class="field" style="margin-top:0;">
          <label>Suchen</label>
          <input id="delinqSearch" placeholder="Name oder Datum (z.B. 1999-01)" />
        </div>

        <div class="list" id="delinqList" style="padding:0; gap:10px;"></div>
      </div>
    </div>
  </div>
</div>



<div class="drawerOverlay hidden" id="drawerOverlay"></div>
<nav class="drawer hidden" id="drawer">
  <div class="drawerTop">
    <div style="display:flex; align-items:center; gap:10px;">
      <div class="logo" style="width:34px;height:34px;border-radius:12px;" id="drawerLogo">TAS</div>
      <div style="min-width:0">
        <div style="font-weight:900; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;" id="drawerAppName">Projekt TAS</div>
        <div class="mhSub" id="drawerUserLine">üî¥ abgemeldet</div>
      </div>
    </div>
    <button class="iconBtn" id="btnCloseDrawer" type="button" aria-label="Men√º schlie√üen">‚úï</button>
  </div>

  <div class="drawerList">
    <button class="drawerBtn active" id="navStart" type="button">üè† Home</button>
    <button class="drawerBtn" id="navFiles" type="button">üìÑ Infos</button>
    <button class="drawerBtn" id="navRanking" type="button">üèÜ Rangliste</button>
    <button class="drawerBtn" id="navCase" type="button">üìù F√§lle</button>
    <button class="drawerBtn" id="navChat" type="button">üí¨ Chat</button>
    <div class="drawerDivider"></div>
    <button class="drawerBtn hidden" id="navAdmin" type="button">üõ°Ô∏è Admin</button>
<button class="drawerBtn" id="navSettings" type="button">‚öôÔ∏è Einstellungen</button>
  </div>

  <div class="drawerFooter">
    <button class="btn small danger" id="drawerLogout" type="button">Logout</button>
    <div class="hint" style="margin-top:10px;">Tipp: Auf Mobile √∂ffnest du das Men√º √ºber ‚ò∞.</div>
  </div>
</nav>
<div class="viewport">

<div class="desktopNavBar" id="desktopNavBar">
  <div class="desktopNavInner">
    <div class="tabs" id="desktopTabs">
      <button class="tabBtn active" id="dnavStart" type="button">üè† Home</button>
      <button class="tabBtn" id="dnavFiles" type="button">üìÑ Infos</button>
      <button class="tabBtn" id="dnavRanking" type="button">üèÜ Rangliste</button>
      <button class="tabBtn" id="dnavCase" type="button">üìù F√§lle</button>
      <button class="tabBtn" id="dnavChat" type="button">üí¨ Chat</button>
<button class="tabBtn" id="dnavSettings" type="button">‚öôÔ∏è Settings</button>
      <button class="tabBtn hidden" id="dnavAdmin" type="button">üõ°Ô∏è Admin</button>
    </div>
    <div class="tabRight">

      <div class="presenceBar" id="presenceBar" style="margin-right:8px;">
        <div class="presenceLabel" id="presenceLabel">offline</div>
        <div class="avatarStack" id="avatarStack"></div>
      </div>

      <div class="chip" id="dnavUserChip">offline</div>
      <button class="btn small danger hidden" id="dnavLogout" type="button">Logout</button>
    </div>
  </div>
</div>

<div class="app" id="appShell">
<!-- SIDEBAR -->
<aside class="card sidebar">
<div class="topbar">
<div class="brand">
<div class="logo" id="appLogo">TAS</div>
<div style="min-width:0">
<h1 id="appName">Projekt TAS</h1>
<div class="sub" id="userLine">üî¥ abgemeldet</div>
</div>
</div>
<div class="statusDot" id="statusDot" title="Login Status"></div>
</div>
<div class="section">
  <div class="row2">
<button class="btn small danger hidden" id="btnLogout" type="button">Logout</button>
  </div>

  <div class="hint" style="margin-top:10px;">
    Profil: Name & Bild kannst du nach dem Login selbst setzen.
  </div>

  <div class="field">
    <label>Dein Name</label>
    <input id="profileName" placeholder="z.B. Max Mustermann"/>
  </div>
  <div class="field">
    <label>Profilbild</label>
    <input id="profilePic" type="file" accept="image/*"/>
  </div>
  <div class="row2" style="margin-top:10px;">
    <button class="btn small" id="btnSaveProfile" type="button">Profil speichern</button>
    <button class="btn small hidden" id="btnOpenAdmin" type="button">Admin</button>
  </div>

  <div class="hint" style="margin-top:10px;">
    Hinweis: Upload/Download-Rechte h√§ngen von deiner Rolle ab.
  </div>
</div>

  <hr style="border:0; border-top:1px solid rgba(255,255,255,.12); margin:14px 0;">
  <div class="hint" style="margin-top:0; font-weight:600;">Push Benachrichtigungen</div>
  <div class="hint" style="margin-top:6px;">
    Damit du im Hintergrund Benachrichtigungen bekommst, musst du Push einmal aktivieren.
  </div>

  <div class="row2" style="margin-top:10px;">
    <button class="btn small" id="btnEnablePush" type="button">üîî Push aktivieren</button>
    <button class="btn small" id="btnDisablePush" type="button">üîï Push deaktivieren</button>
  </div>

  <div class="hint" id="pushStatus" style="margin-top:10px; opacity:.9;">
    Push Status: (noch nicht gepr√ºft)
  </div>

  <div id="pushTokenAdminWrap" class="hidden">
  <textarea id="pushTokenPreview" style="width:100%; min-height:80px; margin-top:8px; border-radius:12px; padding:10px; background:rgba(0,0,0,.25); color:var(--text); border:1px solid rgba(255,255,255,.12);" readonly placeholder="Token wird nach Aktivierung angezeigt..."></textarea>
  </div>

</aside>
<!-- START (MOBILE) -->
<section class="card startPanel" id="startPanel" style="display:none;">
  <div class="topbar">
    <div>
      <div style="font-weight:900; font-size:16px;">Home</div>
      <div class="sub" id="startDate"></div>
    </div>
    <div style="display:flex; align-items:center; gap:10px;">
      <div class="presenceBar" id="presenceBarStartMobile">
        <div class="presenceLabel" id="presenceLabelStartMobile">offline</div>
        <div class="avatarStack" id="avatarStackStartMobile"></div>
      </div>
      <div class="chip">√úbersicht</div>
    </div>
  </div>

  <div class="section">
    <div style="font-weight:900; margin-bottom:8px;">Dienst erfassen</div>

    <div class="row2" style="flex-wrap:wrap;">
      <div class="field" style="flex:1; min-width:180px; margin-top:0;">
        <label>Datum</label>
        <input id="serviceDate" type="date"/>
      </div>
      <div class="field" style="flex:1; min-width:180px; margin-top:0;">
        <label>Personalnummer</label>
        <input id="servicePN" placeholder="z.B. 12345" inputmode="numeric"/>
      </div>
    </div>

    <div class="field" style="margin-top:10px;">
      <label>Name</label>
      <input id="serviceName" placeholder="z.B.Max Mustermann"/>
    </div>

    <div class="row2" style="margin-top:10px; flex-wrap:wrap;">
      <div class="field" style="flex:1; min-width:180px; margin-top:0;">
        <label>Dienstbeginn</label>
        <input id="serviceStartTime" type="time" disabled/>
        <div class="hint" id="serviceRunningLine" style="margin-top:6px;">‚Äî</div>
      </div>
      <div class="field hidden" id="serviceEndWrap" style="flex:1; min-width:180px; margin-top:0;">
        <label>Dienstende</label>
        <input id="serviceEndTime" type="time"/>
      </div>
    </div>

    <div class="row2" style="margin-top:12px; flex-wrap:wrap;">
      <button class="btn primary" id="btnServiceStart" type="button">Dienstbeginn</button>
      <button class="btn" id="btnServiceEnd" type="button" disabled>Dienstende</button>
    </div>

    <div style="margin-top:10px;">
      <button class="btn primary" id="btnServiceSave" type="button" disabled>Speichern</button>
    </div>

    <div class="hint" id="serviceStatusHint" style="margin-top:10px;">Tipp: Dienstbeginn starten ‚Üí danach Dienstende setzen ‚Üí speichern.</div>
  </div>

  <div class="section">
    <details id="servicesDetails" open>
      <summary style="font-weight:900; cursor:pointer;">Erfasste Dienste</summary>
      <div class="list" id="serviceList" style="padding:0; gap:10px; max-height: 340px; overflow:auto; margin-top:10px;"></div>
    </details>
  </div>
</section>
<!-- RANGLISTE -->
<section class="card" id="rankingPanel" style="display:none;">
  <div class="topbar">
    <div>
      <div style="font-weight:900; font-size:16px;">üèÜ Rangliste</div>
      <div class="sub">F√§lle pro Person (Firebase)</div>
    </div>
    <div class="chip">Live</div>
  </div>

  <div class="section">
    <div class="hint" style="margin-bottom:10px;">
      Live-Rangliste aus Firestore. Sortiert nach gemeldeten F√§llen (absteigend).
    </div>

    <div class="list" id="rankingList" style="padding:0; gap:10px;"></div>
  </div>
</section>


<!-- FALL EINTRAGEN -->
<section class="card" id="casePanel" style="display:none;">
  <div class="topbar">
    <div>
      <div style="font-weight:900; font-size:16px;">üìù F√§lle</div>
      <div class="sub">Speicherung &amp; Liste √ºber Firebase</div>
    </div>
    <div class="chip">Live</div>
  </div>

  <div class="section">
    <div class="hint" style="margin-bottom:10px;">
      Trage einen Fall ein (Name, Ort, Datum, Zeit) und speichere ihn. Unten siehst du deine gespeicherten F√§lle.
    </div>

    <div class="field">
      <label>Name</label>
      <input id="caseName" placeholder="z.B. Max Mustermann"/>
    </div>

    <div class="field">
      <label>Ort</label>
      <input id="casePlace" placeholder="z.B. Migros / Filiale XY"/>
    </div>

    <div class="row2" style="margin-top:10px; flex-wrap:wrap;">
      <div class="field" style="flex:1; min-width:180px;">
        <label>Datum</label>
        <input id="caseDate" type="date"/>
      </div>
      <div class="field" style="flex:1; min-width:160px;">
        <label>Zeit</label>
        <input id="caseTime" type="time"/>
      </div>
    </div>

    <div class="row2" style="margin-top:12px; flex-wrap:wrap;">
      <button class="btn primary" id="btnSaveCase" type="button">Speichern</button>
      <button class="btn" id="btnClearCase" type="button">Felder leeren</button>
    </div>
  </div>

  <div class="section">
    <div style="font-weight:900; margin-bottom:10px;">Deine F√§lle</div>
    <div class="list" id="caseList" style="padding:0; gap:10px;"></div>
  </div>
</section>



<!-- MAIN -->
<main class="card main">
<div class="mainHeader">
<div class="searchRow" style="flex:1;">
<input id="searchInput" placeholder="Suchen (Dokumente, Infos, Notizen, Kategorie, Dateiname)..."/>
<select id="typeFilter" style="max-width:170px;">
<option value="all">Alles</option>
<option value="doc">Dokumente</option>
<option value="img">Bilder</option>
</select>
<button class="btn small" id="btnNotify">üîî Notify</button>
</div>
</div>

<div class="dropzone" id="dropzone">
  <div style="font-weight:900; font-size:16px; color:var(--text);">üìÅ Dokumente</div>
  <div class="hint" style="margin-top:6px;">
    Alle relevanten Dokumente liegen zentral im Google Drive. √ñffne den Ordner √ºber den Button.
  </div>
  <div style="margin-top:12px; display:flex; justify-content:center;">
    <button class="btn primary" id="btnOpenDrive" type="button">Google Drive √∂ffnen</button>
  </div>
</div>

<div class="dropzone" id="activeDutyZone" style="margin-top:14px;">
  <div style="font-weight:900; font-size:16px; color:var(--text);">üü¢ Aktiv im Dienst</div>
  <div class="hint" style="margin-top:6px;">
    Hier siehst du alle, die  <b>Aktiv im Dienst</b> sind.
  </div>
  <div class="active-duty-grid" id="activeDutyGrid"></div>
</div>

<div class="dropzone" id="securiReportZone" style="margin-top:14px;">
  <div class="securireport-card">
    <div class="card-header">
      <span class="icon">üõ°Ô∏è</span>
      <span class="title">SecuriReport +</span>
    </div>
    <p class="card-text">√ñffne SecuriReport direkt im Browser.</p>
    <button class="btn primary" id="btnOpenSecuriReport" type="button" style="margin-top:16px" onclick="(function(){var u='https://securireport3.securitas.ch/securireport/desktop-app/#login'; try{var w=window.open(u, '_blank', 'noopener,noreferrer'); if(!w) window.location.href=u;}catch(e){window.location.href=u;}})()">SecuriReport √∂ffnen</button>
  </div>
</div>

<div class="dropzone" id="delinqZone" style="margin-top:14px;">
  <div class="securireport-card">
    <div class="card-header">
      <span class="icon">üóÉÔ∏è</span>
      <span class="title">Delinquenten Datenbank</span>
    </div>
    <p class="card-text">Liste der eingetragenen Delinquenten (mit Suche &amp; Eintrag).</p>
    <button class="btn primary" id="btnOpenDelinq" type="button" style="margin-top:16px">Datenbank √∂ffnen</button>
  </div>
</div>

</div>

<div class="grid hidden" id="fileGrid"></div>



</main>
<!-- RIGHT: CHAT + AUTH -->
<aside class="card rightbar">
<div class="topbar">
<div style="font-weight:900">Chat</div>
<div style="display:flex; align-items:center; gap:10px; min-width:0;">  <div class="presenceBar" id="presenceBarChatMobile">    <div class="presenceLabel" id="presenceLabelChatMobile">offline</div>    <div class="avatarStack" id="avatarStackChatMobile"></div>  </div>  <div class="chip" id="chatMode">lokal</div></div>
</div>
<div class="hint" style="padding:0 12px 4px; color: var(--muted);">Chat-Raum: <b>global</b></div>
<div class="hint hidden" id="typingLine" style="padding:0 12px 10px; color: var(--muted);">üü¢ jemand tippt‚Ä¶</div>
<div class="chat">
<div class="chatLog" id="chatLog"></div>
<div class="chatInput">
<input id="chatText" placeholder="Nachricht..."/>
<button class="btn primary" id="btnSend" type="button">Senden</button>
</div>
</div>
</aside>
</div>
</div>
</div>
<script type="module">
// ===== Push/FCM: Service Worker Registrierung (muss im Root liegen) =====
const SW_URL = "/firebase-messaging-sw.js";
const swReady = (async () => {
  if (!("serviceWorker" in navigator)) return null;
  try {
    const reg = await navigator.serviceWorker.register(SW_URL);
    await navigator.serviceWorker.ready;
    console.log("‚úÖ SW ready:", reg.scope);
    return reg;
  } catch (e) {
    console.error("‚ùå SW register failed:", e);
    return null;
  }
})();

/**
 * Projekt TAS ‚Äì Firebase Edition (Single-File)
 * - Firebase Auth (Email/Pass; "Benutzername" ohne @ wird zu @tas.local gemappt)
 * - Firestore: Kategorien, Items (Metadaten/Notizen), Chat (Realtime)
 * - Storage: deaktiviert (Spark Plan) ‚Äì Uploads werden im UI deaktiviert
 *
 * WICHTIG (Deploy):
 * 1) In Firebase Console: Authentication -> Email/Password aktivieren
 * 2) Firestore + Storage aktivieren
 * 3) Security Rules anpassen (Beispiel am Ende dieses Scripts)
 */

import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
import {
  getAuth, onAuthStateChanged,
  createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut,
  updateProfile
} from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";
import {
  getFirestore,
  collection,
  doc,
  addDoc,
  setDoc,
  updateDoc,
  deleteDoc,
  query,
  orderBy,
  where,
  getDoc,
  getDocs,
  onSnapshot,
  serverTimestamp,
  Timestamp,
  deleteField,
  limit} from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";
import { getMessaging, getToken, deleteToken, onMessage, isSupported as messagingIsSupported } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-messaging.js";

const firebaseConfig = {
  apiKey: "AIzaSyAU-gtZxzBOCIDYrqQ82Su8qslcWAcOE9o",
  authDomain: "ladendetektiv-app.firebaseapp.com",
  projectId: "ladendetektiv-app",
  storageBucket: "ladendetektiv-app.firebasestorage.app",
  messagingSenderId: "1039057164732",
  appId: "1:1039057164732:web:0c7907a83bdbe21e95b3b9"
};

// Hinweis: Firebase Auth funktioniert nicht √ºber file:// ‚Äì bitte √ºber http(s) √∂ffnen (z.B. VSCode Live Server).
if (location.protocol === "file:") {
  console.warn("Du √∂ffnest die Datei per file://. Bitte starte einen lokalen Webserver (z.B. VSCode Live Server), sonst kann Firebase Auth fehlschlagen.");
}

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);

// ---------- Power Automate Webhook (Dienstzeit -> Teams) ----------
const FLOW_URL_DIENSTZEIT = 'https://default37df5520fb854c58aa126bafbea273.f4.environment.api.powerplatform.com:443/powerautomate/automations/direct/workflows/0ce4602e433446ee87e52dd7494e76a0/triggers/manual/paths/invoke?api-version=1&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=NOVErBbD9Q2_hBUiVaf6eMxMaiUstp5rVhU4DN42WJc';

// Sends Dienstzeit payload to Power Automate.
// Note: Many Power Automate HTTP triggers do not send CORS headers.
// Using mode:'no-cors' avoids the browser blocking the request; the flow will still receive it.
async function notifyTeamsDienstzeit(payload){
  try{
    await fetch(FLOW_URL_DIENSTZEIT, {
      method: "POST",
      mode: "no-cors",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });
  }catch(e){
    console.warn("Teams/Flow Notify failed:", e);
  }
}


// Viele Projekte nutzen als Bucket-Namen weiterhin <projectId>.appspot.com.
// ---------- DOM helpers ----------
const $ = (id) => document.getElementById(id);
const uid = () => crypto.randomUUID();
const fmtDate = (ts) => new Date(ts).toLocaleString("de-CH");
function escapeHtml(s){
  return (s||"").replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
}

var shouldAutoScroll = window.shouldAutoScroll || function(container, threshold = 80){
  if(!container) return true;
  return (container.scrollHeight - container.scrollTop - container.clientHeight) < threshold;
};
window.shouldAutoScroll = shouldAutoScroll;

function scrollToBottom(el){
  if(!el) return;
  el.scrollTop = el.scrollHeight;
  // double-tick for layout timing (no recursion!)
  setTimeout(()=>{ el.scrollTop = el.scrollHeight; }, 60);
}


// Global error catcher: zeigt Fehler, falls das Script in mobilen WebViews fr√ºh abst√ºrzt
window.addEventListener("error", (ev)=>{
  console.error(ev.error || ev.message);
  const box = document.getElementById("authErrorBox");
  if(box){
    box.textContent = "JS Fehler: " + (ev.error?.message || ev.message || String(ev));
    box.classList.remove("hidden");
  }
});
window.addEventListener("unhandledrejection", (ev)=>{
  console.error(ev.reason);
  const box = document.getElementById("authErrorBox");
  if(box){
    box.textContent = "Promise Fehler: " + (ev.reason?.message || String(ev.reason||ev));
    box.classList.remove("hidden");
  }
});

// ---------- State ----------
var chatRoles = window.chatRoles || {};
window.chatRoles = chatRoles;

const STORAGE_DISABLED = true; // Spark Plan: kein Firebase Storage
let state = {
  selectedCatId: "all",
  search: "",
  typeFilter: "all",
  cats: [],
  items: [],
  session: null, // {uid, email, user}
  chatRoom: "Raum: Global",
  unsubCats: null,
  unsubItems: null,
  unsubChat: null,
  unsubCases: null,
  unsubServices: null,
  cases: [],
  services: [],
  rankings: [],
  };

// ---------- Auth utils ----------
function normalizeEmail(input){
  const v = (input||"").trim();
  if(!v) return "";
  if(v.includes("@")) return v.toLowerCase();
  // allow "Benutzername" ohne Email -> map to pseudo-domain
  return `${v.toLowerCase()}@tas.local`;
}

function displayNameFromEmail(email){
  if(!email) return "Gast";
  return (email.split("@")[0] || email).trim();
}


async function fileToAvatarDataUrl(file, maxSize=256, quality=0.78){
  // Converts an image File into a small square JPEG dataURL (Spark-plan friendly, no Storage).
  if(!file) return "";
  const img = await new Promise((resolve, reject) => {
    const url = URL.createObjectURL(file);
    const i = new Image();
    i.onload = () => { URL.revokeObjectURL(url); resolve(i); };
    i.onerror = (e) => { URL.revokeObjectURL(url); reject(new Error("Bild konnte nicht geladen werden.")); };
    i.src = url;
  });

  const canvas = document.createElement("canvas");
  canvas.width = maxSize;
  canvas.height = maxSize;
  const ctx = canvas.getContext("2d");

  // cover-crop to square
  const iw = img.naturalWidth || img.width;
  const ih = img.naturalHeight || img.height;
  const scale = Math.max(maxSize / iw, maxSize / ih);
  const sw = maxSize / scale;
  const sh = maxSize / scale;
  const sx = (iw - sw) / 2;
  const sy = (ih - sh) / 2;

  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";
  ctx.clearRect(0, 0, maxSize, maxSize);
  ctx.drawImage(img, sx, sy, sw, sh, 0, 0, maxSize, maxSize);

  return canvas.toDataURL("image/jpeg", quality);
}


function applySessionUI(){
  const dot = $("statusDot");
  const line = $("userLine");
  const logoutBtn = $("btnLogout");
  const chatMode = $("chatMode");

  const overlay = $("authOverlay");
  const appShell = $("appShell");


// Mobile header / drawer mirrors
const mhAppName = document.getElementById("mhAppName");
const drawerAppName = document.getElementById("drawerAppName");
const mhUserChip = document.getElementById("mhUserChip");
const drawerUserLine = document.getElementById("drawerUserLine");
const drawerLogo = document.getElementById("drawerLogo");
if(mhAppName) mhAppName.textContent = document.getElementById("appName")?.textContent || "Projekt TAS";
if(drawerAppName) drawerAppName.textContent = document.getElementById("appName")?.textContent || "Projekt TAS";
if(drawerLogo) drawerLogo.textContent = document.getElementById("appLogo")?.textContent || "TAS";
if(mhUserChip) mhUserChip.textContent = state.session?.uid ? (state.session.user || state.session.email) : "offline";
if(drawerUserLine) drawerUserLine.textContent = state.session?.uid ? ("üü¢ " + (state.session.user || state.session.email)) : "üî¥ abgemeldet";

// Desktop nav mirrors
const dnavUserChip = document.getElementById("dnavUserChip");
const dnavLogout = document.getElementById("dnavLogout");
if(dnavUserChip) dnavUserChip.textContent = state.session?.uid ? (state.session.user || state.session.email) : "offline";
if(dnavLogout){
  if(state.session?.uid) dnavLogout.classList.remove("hidden");
  else dnavLogout.classList.add("hidden");
}

  if(state.session?.uid){
    dot.classList.add("ok");
    line.textContent = "üü¢ angemeldet als " + (state.session.user || state.session.email);
    logoutBtn.classList.remove("hidden");
    chatMode.textContent = `${(state.chatRoom||"Raum: Allgemein")}`;
  } else {
    dot.classList.remove("ok");
    line.textContent = "üî¥ abgemeldet";
    logoutBtn.classList.add("hidden");
    chatMode.textContent = "offline";
  }

  // Gate: Ohne Login keine App-Bedienung
  if(state.session?.uid){
    overlay?.classList.add("hidden");
    appShell?.classList.remove("hidden");
  } else {
    overlay?.classList.remove("hidden");
    appShell?.classList.add("hidden");
  }
}

function explainFirebaseAuthError(err){
  const code = err?.code || "";
  const msg = err?.message || String(err || "");
  // H√§ufige Ursachen + klare Hinweise
  if(code === "auth/configuration-not-found" || msg.includes("CONFIGURATION_NOT_FOUND") || msg.includes("configuration-not-found")){
    return "Firebase Auth Konfiguration nicht gefunden (auth/configuration-not-found).\n\nCheckliste:\n1) √ñffne die Seite √ºber http(s) (nicht file://).\n2) Firebase Console ‚Üí Authentication ‚Üí Sign-in method ‚Üí Email/Password aktivieren.\n3) API-Key Restrictions pr√ºfen (HTTP Referrer / localhost erlauben).\n4) Pr√ºfen ob apiKey wirklich zu projectId passt.";
  }
  if(code === "auth/operation-not-allowed"){
    return "Login/Registrierung ist f√ºr dieses Projekt nicht erlaubt. Bitte Firebase Console ‚Üí Authentication ‚Üí Email/Password aktivieren.";
  }
  if(code === "auth/user-not-found"){
    return "Dieser Nutzer existiert nicht. Bitte erst registrieren oder Benutzername/Email pr√ºfen.";
  }
  if(code === "auth/wrong-password"){
    return "Falsches Passwort.";
  }
  if(code === "auth/email-already-in-use"){
    return "Diese Email wird bereits verwendet. Bitte einloggen.";
  }
  if(code === "auth/invalid-email"){
    return "Ung√ºltige Email. (Tipp: Benutzername ohne @ wird automatisch zu @tas.local erg√§nzt.)";
  }
  return msg;
}


// ---------- App Security / Roles / Profile ----------
const CFG_SECURITY = doc(db, "appConfig", "security"); // { whitelist: [email], admins:[uid] }
const ROLES_COL = collection(db, "appConfig", "global", "roles"); // subcollection under appConfig/global
const USERROLES_COL = collection(db, "appConfig", "global", "userRoles"); // subcollection under appConfig/global




// --- Fixed bootstrap admin (hardcoded) ---
const FIXED_ADMIN = {
  email: "itbetas2@gmail.com".toLowerCase(),
  uid: "FVoqT70QeneHgiBcvEG3m0u1Pku1"
};
function uniq(arr){
  return Array.from(new Set((arr||[]).filter(Boolean)));
}
state.profile = { displayName:"", photoURL:"" };
state.roleName = "Mitarbeiter";
state.role = { canUpload:false, canDownload:true, canAdmin:false };
state.onlineUsers = [];
state.unsubPresence = null;


state.unsubMyProfile = null;
function perms(){
  return state.role || { canUpload:false, canDownload:true, canAdmin:false };
}



function isAdminUser(){
  const isFixedAdmin = !!(state.session?.uid && (state.session.uid === FIXED_ADMIN.uid || String(state.session.email||"").toLowerCase() === FIXED_ADMIN.email));
  return !!(perms().canAdmin || isFixedAdmin);
}

function applyPushUiVisibility(){
  const wrap = document.getElementById("pushTokenAdminWrap");
  const t = document.getElementById("pushTokenPreview");
  const admin = isAdminUser();
  if(wrap){
    wrap.classList.toggle("hidden", !admin);
  }
  if(t && !admin){
    t.value = "";
    t.placeholder = "Token (nur Admin sichtbar)";
  }
}

function checkPushState(){
  const uid = state.session?.uid;
  if(!uid){
    setPushUiStatus("Push Status: (bitte einloggen)", false);
    return;
  }
  const last = localStorage.getItem("fcmToken:last:" + uid) || "";
  if(last){
    setPushUiStatus("‚úÖ Push aktiv (Token gespeichert).", true);
  } else {
    setPushUiStatus("üîï Push deaktiviert.", true);
  }
  const t = document.getElementById("pushTokenPreview");
  if(t){
    if(isAdminUser()) t.value = last || "";
    else t.value = "";
  }
}

function applyPermsUI(){
  const p = perms();
  const isFixedAdmin = !!(state.session?.uid && (state.session.uid === FIXED_ADMIN.uid || String(state.session.email||"").toLowerCase() === FIXED_ADMIN.email));
  // Upload controls
  const dz = document.getElementById("dropzone");
  const pick = document.getElementById("btnPickFiles");
  const fp = document.getElementById("filePicker");
  if(!p.canUpload){
    if(pick) { pick.disabled = true; pick.classList.add("hidden"); } // hide button, keep area
    if(fp) fp.disabled = true;
    if(dz){
      dz.style.opacity = "0.65";
    }
  } else {
    if(pick) { pick.disabled = false; pick.classList.remove("hidden"); }
    if(fp) fp.disabled = false;
    if(dz){
      dz.style.opacity = "";
      dz.style.pointerEvents = "";
    }
  }
  // Admin controls
  const btnAdmin = document.getElementById("btnOpenAdmin");
  const navAdmin = document.getElementById("navAdmin");
  const dnavAdmin = document.getElementById("dnavAdmin");
  if(p.canAdmin || isFixedAdmin){
    btnAdmin?.classList.remove("hidden");
    navAdmin?.classList.remove("hidden");
    dnavAdmin?.classList.remove("hidden");
  } else {
    btnAdmin?.classList.add("hidden");
    navAdmin?.classList.add("hidden");
    dnavAdmin?.classList.add("hidden");
  }

  // Push token preview: nur Admin sichtbar
  try{ applyPushUiVisibility(); }catch(_e){}
}

function roleDefaults(){
  return {
    "Leitung": { name:"Leitung", canUpload:true, canDownload:true, canAdmin:true },
    "Mitarbeiter": { name:"Mitarbeiter", canUpload:false, canDownload:true, canAdmin:false },
  };
}

async function ensureDefaultDocs(){
  // Ensure security doc exists
  const secSnap = await getDoc(CFG_SECURITY).catch(()=>null);
  if(!secSnap || !secSnap.exists()){
    await setDoc(CFG_SECURITY, { whitelist: [FIXED_ADMIN.email], admins: [FIXED_ADMIN.uid], updatedAt: serverTimestamp() }, { merge:true });
  }

  // Always ensure fixed admin is present
  try{
    const sec2 = await getDoc(CFG_SECURITY);
    const data = sec2.data() || {};
    const admins = uniq([...(data.admins||[]), FIXED_ADMIN.uid]);
    const whitelist = uniq([...(data.whitelist||[]), FIXED_ADMIN.email]);
    await setDoc(CFG_SECURITY, { admins, whitelist, updatedAt: serverTimestamp() }, { merge:true });
  }catch(_e){}
  // Ensure roles exist
  const rolesSnap = await getDocs(ROLES_COL).catch(()=>null);
  if(rolesSnap && rolesSnap.empty){
    const defs = roleDefaults();
    for(const [name, data] of Object.entries(defs)){
      await setDoc(doc(db, "appConfig", "global", "roles", name), { ...data, updatedAt: serverTimestamp() }, { merge:true });
    }
  }
}

async function isEmailAllowed(email){
  const secSnap = await getDoc(CFG_SECURITY).catch(()=>null);
  const wl = secSnap?.data()?.whitelist || [];
  if(!wl.length) return true; // empty whitelist -> allow all
  const e = (email||"").toLowerCase();
  return wl.map(x=>String(x||"").toLowerCase()).includes(e);
}

async function loadMyRole(email, uid){
  // 1) Explicit user role by email
  let roleName = null;
  try{
    const ur = await getDoc(doc(db, "appConfig", "global", "userRoles", (email||"").toLowerCase())).catch(()=>null);
    roleName = ur?.data()?.role || null;
  }catch(_e){}
  // 2) Bootstrap: first user becomes admin if admins empty
  const secSnap = await getDoc(CFG_SECURITY).catch(()=>null);
  const admins = secSnap?.data()?.admins || [];
  if(admins.length === 0){
    await setDoc(CFG_SECURITY, { admins: uniq([FIXED_ADMIN.uid, uid].filter(Boolean)), updatedAt: serverTimestamp() }, { merge:true });
  }
  const adminsList = (secSnap?.data()?.admins || []);
  const isAdmin = adminsList.includes(uid) || (String(email||"").toLowerCase() === FIXED_ADMIN.email) || (uid === FIXED_ADMIN.uid);

  // 3) If admin but no explicit role -> Leitung
  if(isAdmin && !roleName) roleName = "Leitung";
  if(!roleName) roleName = "Mitarbeiter";

  // load role document
  const rSnap = await getDoc(doc(db, "appConfig", "global", "roles", roleName)).catch(()=>null);
  const role = rSnap?.data() || roleDefaults()[roleName] || roleDefaults()["Mitarbeiter"];

  state.roleName = roleName;
  state.role = {
    canUpload: !!role.canUpload,
    canDownload: !!role.canDownload,
    canAdmin: !!role.canAdmin,
  };
  // Hard override: FIXED_ADMIN always has Admin-Rechte
  if((String(email||"").toLowerCase() === FIXED_ADMIN.email) || (uid === FIXED_ADMIN.uid)){
    state.role.canAdmin = true;
    state.role.canUpload = true;
    state.role.canDownload = true;
  }
  applyPermsUI();
}

async function loadMyProfile(uid){
  const pSnap = await getDoc(doc(db, "users", uid)).catch(()=>null);
  const data = pSnap?.data() || {};
  state.profile.displayName = data.displayName || state.session?.user || "";
  state.profile.photoURL = data.photoURL || data.avatarDataUrl || "";

  // mark loaded + mirror into session so Presence/Dienstbeginn has the avatar immediately
  state.profileLoaded = true;
  if(state.session){
    state.session.photoURL = state.profile.photoURL || "";
    state.session.avatarDataUrl = state.profile.photoURL || "";
  }

  const nameInp = document.getElementById("profileName");
  if(nameInp) nameInp.value = state.profile.displayName || "";

  // Preload avatar to avoid "late image" when switching to Aktiv im Dienst
  try{
    if(state.profile.photoURL){
      const im = new Image();
      im.src = state.profile.photoURL;
      im.decoding = "async";
      im.loading = "eager";
    }
  }catch(_e){}
}

// Live-profile watcher (fixes avatar/name flipping when multiple tabs/devices are open)
function watchMyProfile(uid){
  if(state.unsubMyProfile) { try{ state.unsubMyProfile(); }catch(_){} }
  if(!uid) return;
  state.unsubMyProfile = onSnapshot(doc(db, "users", uid), (snap)=>{
    const data = snap.data() || {};
    const newName = data.displayName || state.session?.user || "";
    const newPhoto = data.photoURL || data.avatarDataUrl || "";

    const changed = (newName !== state.profile.displayName) || (newPhoto !== state.profile.photoURL);

    state.profile.displayName = newName;
    state.profile.photoURL = newPhoto;

    state.profileLoaded = true;
    if(state.session){
      state.session.photoURL = state.profile.photoURL || "";
      state.session.avatarDataUrl = state.profile.photoURL || "";
    }

    // Preload avatar when it changes
    try{
      if(state.profile.photoURL){
        const im = new Image();
        im.src = state.profile.photoURL;
        im.decoding = "async";
        im.loading = "eager";
      }
    }catch(_e){} 

    if(state.session?.uid){
      // keep session label consistent
      if(newName) state.session.user = newName;
      applySessionUI();
      if(changed){
        // push updated avatar/name into presence so everyone sees the latest
        upsertPresence().catch(()=>{});
      }
    }
  }, (err)=>{
    console.warn("watchMyProfile error:", err);
  });
}


async function saveMyProfile(){
  const uid = requireLogin();
  const name = (document.getElementById("profileName")?.value || "").trim();
  const pic = document.getElementById("profilePic")?.files?.[0];

  let avatarDataUrl = state.profile.photoURL || "";
  if(pic){
    // Spark Plan friendly: store small avatar directly in Firestore (no Storage).
    avatarDataUrl = await fileToAvatarDataUrl(pic);
    // Firestore doc limit safety
    if(avatarDataUrl.length > 700_000){
      throw new Error("Bild ist zu gro√ü. Bitte ein kleineres Bild w√§hlen.");
    }
  }

  const displayName =
    name || state.profile.displayName || displayNameFromEmail(state.session?.email);

  await setDoc(doc(db, "users", uid), {
    email: state.session?.email || "",
    displayName,
    avatarDataUrl: avatarDataUrl || "",
    photoURL: "", // reserved if you later switch to Storage/URL
    updatedAt: serverTimestamp()
  }, { merge:true });

  state.profile.displayName = displayName;
  state.profile.photoURL = avatarDataUrl || "";
  state.session.user = displayName;

  applySessionUI();
  await upsertPresence().catch(()=>{});
  alert("Profil gespeichert.");
}


// Ensure we have profile (name + avatar) before writing Presence / Dienstbeginn,
// so the avatar is visible immediately (no "late loading" after Dienstbeginn).
async function ensureMyProfileLoaded(){
  try{
    if(!state.session?.uid) return;
    if(state.profileLoaded) return;
    await loadMyProfile(state.session.uid).catch(()=>{});
    state.profileLoaded = true;
  }catch(_e){}
}

// ---------- Presence ----------
const PRESENCE_COL = collection(db, "presence");

// --- Aktiv im Dienst (Presence) ---
async function setInService(flag){
    requireLogin();
    await ensureMyProfileLoaded();
    const uid = state.session.uid;
    const u = state.session;

    // IMPORTANT:
    // - Beim Start: inService=true + serviceStartedAt setzen, serviceEndedAt entfernen
    // - Beim Stop (nach Speichern): inService=false + serviceEndedAt setzen
    // - serviceStartedAt NICHT wieder auf null setzen (sonst kann man den Dienststatus nicht mehr sauber auswerten)
    const base = {
      uid,
      displayName: u.displayName || u.user || "User",
      email: u.email || "",
      photoURL: state.profile?.photoURL || u.photoURL || u.avatarDataUrl || ""};

    if(flag){
      await setDoc(doc(db, "presence", uid), {
        ...base,
        inService: true,
        serviceStartedAt: serverTimestamp(),
        serviceEndedAt: deleteField(),
        serviceUpdatedAt: serverTimestamp(),
      }, { merge: true });
    } else {
      await setDoc(doc(db, "presence", uid), {
        ...base,
        inService: false,
        serviceEndedAt: serverTimestamp(),
        serviceUpdatedAt: serverTimestamp(),
      }, { merge: true });
    }
  }

let unsubActiveDuty = null;
function watchActiveDuty(){
  try{
    if(unsubActiveDuty){ unsubActiveDuty(); unsubActiveDuty=null; }
    const grid = document.getElementById('activeDutyGrid');
    if(!grid) return;
    const q = query(PRESENCE_COL, where('inService','==',true), limit(4));
    unsubActiveDuty = onSnapshot(q, (snap)=>{
      const items = [];
      snap.forEach(d=>items.push({id:d.id, ...d.data()}));
      renderActiveDuty(items);
    }, (err)=>{
      console.warn('watchActiveDuty snapshot error', err);
    });
  }catch(e){
    console.warn('watchActiveDuty failed', e);
  }
}

function renderActiveDuty(list){
  const grid = document.getElementById('activeDutyGrid');
  if(!grid) return;
  if(!list || list.length===0){
    grid.innerHTML = `<div class=\"active-duty-empty\">Aktuell ist niemand im Dienst.</div>`;
    return;
  }
  grid.innerHTML = list.map(u=>{
    const name = (u.displayName || u.user || u.email || 'User');
    const src = u.avatarDataUrl || u.photoURL || u.photoUrl || '';
    const initials = (name||'U').trim().slice(0,1).toUpperCase();
    const img = src ? `<img class=\"active-duty-avatar\" src=\"${src}\" alt=\"${name}\" loading=\"eager\" decoding=\"async\"/>` : `<div class=\"active-duty-avatar\" style=\"display:flex;align-items:center;justify-content:center;font-weight:900;\">${initials}</div>`;
    return `<div class=\"active-duty-item\">${img}<div class=\"active-duty-name\">${name}</div></div>`;
  }).join('');
}


async function upsertPresence(){
  if(!state.session?.uid) return;
  const uid = state.session.uid;
  const ref = doc(db, "presence", uid);
  await setDoc(ref, {
    uid,
    email: state.session.email || "",
    displayName: state.profile.displayName || state.session.user || displayNameFromEmail(state.session.email),
    photoURL: state.profile.photoURL || "",
    online: true,
    lastSeen: serverTimestamp()
  }, { merge:true });
}

async function setOffline(){
  if(!state.session?.uid) return;
  try{
    await updateDoc(doc(db, "presence", state.session.uid), { online:false, lastSeen: serverTimestamp() });
  }catch(_e){}
}

function watchPresence(){
  if(state.unsubPresence) state.unsubPresence();
  state.unsubPresence = onSnapshot(PRESENCE_COL, (snap)=>{
    const now = Date.now();
    const online = [];
    snap.forEach(d=>{
      const p = d.data() || {};
      const ls = p.lastSeen?.toMillis ? p.lastSeen.toMillis() : (p.lastSeen || 0);
      // Consider user online if online flag true and lastSeen within 2 minutes
      if(p.online && (now - ls) < 2*60*1000){
        online.push({ uid:d.id, ...p, lastSeen: ls });
      }
    });
    online.sort((a,b)=> (b.lastSeen||0) - (a.lastSeen||0));
    state.onlineUsers = online;
    renderPresenceBar();
  });
}

function renderPresenceBar(){
const label = document.getElementById("presenceLabel");
  const stack = document.getElementById("avatarStack");
  const labelStartM = document.getElementById("presenceLabelStartMobile");
  const stackStartM = document.getElementById("avatarStackStartMobile");
  const labelChatM = document.getElementById("presenceLabelChatMobile");
  const stackChatM = document.getElementById("avatarStackChatMobile");
  const hasAny = (label && stack) || (labelStartM && stackStartM) || (labelChatM && stackChatM);
  if(!hasAny) return;

  if(!state.session?.uid){
    label.textContent = "offline";
    stack.innerHTML = "";
    return;
  }

  const online = state.onlineUsers || [];
  if(label) label.textContent = online.length ? `Online: ${online.length}` : "Online: 0";
  if(stack) stack.innerHTML = "";
  if(labelStartM) labelStartM.textContent = online.length ? `Online: ${online.length}` : "Online: 0";
  if(stackStartM) stackStartM.innerHTML = "";
  if(labelChatM) labelChatM.textContent = online.length ? `Online: ${online.length}` : "Online: 0";
  if(stackChatM) stackChatM.innerHTML = "";

  online.slice(0, 6).forEach(u=>{
    const a = document.createElement("div");
    a.className = "avatar";
    a.title = u.displayName || u.email || "User";
    if(u.photoURL){
      const img = document.createElement("img");
      img.src = u.photoURL;
      img.alt = u.displayName || "avatar";
      a.appendChild(img);
    } else {
      a.textContent = (u.displayName||u.email||"U").trim().slice(0,1).toUpperCase();
    }
    const dot = document.createElement("div");
    dot.className = "onlineDot";
    a.appendChild(dot);
    if(stack) stack.appendChild(a.cloneNode(true));
    if(stackStartM) stackStartM.appendChild(a.cloneNode(true));
    if(stackChatM) stackChatM.appendChild(a);
  });
}

// Heartbeat + offline best-effort
let presenceTimer = null;
function startPresence(){
  stopPresence();
  upsertPresence().catch(()=>{});
  presenceTimer = setInterval(()=> upsertPresence().catch(()=>{}), 30_000);
  window.addEventListener("beforeunload", setOffline);
  document.addEventListener("visibilitychange", ()=>{
    if(document.hidden) setOffline();
    else upsertPresence().catch(()=>{});
  });
}
function stopPresence(){
  if(presenceTimer) clearInterval(presenceTimer);
  presenceTimer = null;
  window.removeEventListener("beforeunload", setOffline);
}

// ---------- Admin UI ----------

function setupAdminTabs(){
  const overlay = document.getElementById("adminOverlay");
  if(!overlay) return;

  const nav = overlay.querySelector("#adminNav");
  const btns = nav ? Array.from(nav.querySelectorAll("[data-admin-tab]")) : [];
  const pages = Array.from(overlay.querySelectorAll("[data-admin-page]"));
  if(!btns.length || !pages.length) return;

  const activate = (key)=>{
    btns.forEach(b=>b.classList.toggle("active", b.dataset.adminTab === key));
    pages.forEach(p=>p.classList.toggle("hidden", p.dataset.adminPage !== key));
    try{ localStorage.setItem("adminTab:last", key); }catch(_e){}
  };

  // Avoid double binding
  if(!nav.dataset.bound){
    nav.dataset.bound = "1";
    btns.forEach(b=> b.addEventListener("click", ()=> activate(b.dataset.adminTab)));
  }

  const last = (function(){ try{ return localStorage.getItem("adminTab:last") || "access"; }catch(_e){ return "access"; }})();
  activate(last);
}
function openAdmin(){
  document.getElementById("adminOverlay")?.classList.remove("hidden");
  setupAdminTabs(); // safe to call multiple times
  loadAdminUI().catch((e)=>{ console.error(e); alert("Admin-UI Fehler: " + (e?.message||e)); });
}
function closeAdmin(){
  document.getElementById("adminOverlay")?.classList.add("hidden");
  stopRoleOverview(); // Listener sauber beenden
}


let _unsubRoleOverviewUsers = null;
let _unsubRoleOverviewRoles = null;

function stopRoleOverview(){
  try{ _unsubRoleOverviewUsers?.(); }catch(_e){}
  try{ _unsubRoleOverviewRoles?.(); }catch(_e){}
  _unsubRoleOverviewUsers = null;
  _unsubRoleOverviewRoles = null;
}

function startRoleOverview(){
  if(!perms().canAdmin) return;

  // keine doppelten Listener
  stopRoleOverview();

  const tbl = document.getElementById("roleOverviewTable");
  const hint = document.getElementById("roleOverviewHint");
  const searchEl = document.getElementById("roleOverviewSearch");
  const refreshBtn = document.getElementById("btnRefreshRoleOverview");
  if(!tbl || !hint) return;

  let rolesMap = {};
  let userRows = [];

  const paint = () => {
    const q = (searchEl?.value || "").trim().toLowerCase();

    const rows = userRows
      .map(u => {
        const roleId = (u.role || u.roleId || "").trim();
        const roleMeta = rolesMap[roleId] || {};
        const label = roleMeta.label || roleMeta.name || roleId || "‚Äî";
        const rights = roleMeta.rights || roleMeta.permissions || roleMeta.perms || {};
        const rightsTxt = Object.keys(rights).filter(k => rights[k]).join(", ");
        return { email: u.email, roleId, label, rightsTxt };
      })
      .filter(r => {
        if(!q) return true;
        return (r.email || "").includes(q) || (r.roleId || "").toLowerCase().includes(q) || (r.label || "").toLowerCase().includes(q);
      })
      .sort((a,b) => (a.email||"").localeCompare(b.email||""));

    hint.textContent = `${rows.length} Eintr√§ge`;

    // Tabelle rendern
    const header = `
      <tr>
        <th style="text-align:left; font-size:12px; opacity:.8; padding:0 10px;">E-Mail</th>
        <th style="text-align:left; font-size:12px; opacity:.8; padding:0 10px;">Rolle</th>
        <th style="text-align:left; font-size:12px; opacity:.8; padding:0 10px;">Rechte</th>
      </tr>`;
    const body = rows.map(r => `
      <tr style="background:rgba(0,0,0,.22); border:1px solid var(--border);">
        <td style="padding:10px; border-radius:12px 0 0 12px; word-break:break-word;">${escapeHtml(r.email || "‚Äî")}</td>
        <td style="padding:10px; min-width:130px;">${escapeHtml(r.label || r.roleId || "‚Äî")}</td>
        <td style="padding:10px; border-radius:0 12px 12px 0; opacity:.9;">${escapeHtml(r.rightsTxt || "‚Äî")}</td>
      </tr>`).join("");

    tbl.innerHTML = header + body;
  };

  // UI-Events einmal binden
  if(searchEl && !searchEl.dataset.bound){
    searchEl.addEventListener("input", paint);
    searchEl.dataset.bound = "1";
  }
  if(refreshBtn && !refreshBtn.dataset.bound){
    refreshBtn.addEventListener("click", paint);
    refreshBtn.dataset.bound = "1";
  }

  // Live Daten: Rollen + UserRoles
  _unsubRoleOverviewRoles = onSnapshot(ROLES_COL, (snap) => {
    rolesMap = {};
    snap.forEach(d => rolesMap[d.id] = d.data() || {});
    paint();
  });

  _unsubRoleOverviewUsers = onSnapshot(USERROLES_COL, (snap) => {
    userRows = snap.docs.map(d => ({ email: d.id, ...(d.data()||{}) }));
    paint();
  });

  paint();
}


async function loadAdminUI(){
  if(!perms().canAdmin) return alert("Keine Admin-Rechte.");
  await ensureDefaultDocs();
  // whitelist
  const secSnap = await getDoc(CFG_SECURITY);
  const wl = (secSnap.data()?.whitelist || []).join("\n");
  const box = document.getElementById("whitelistBox");
  if(box) box.value = wl;

  // roles dropdown
  const sel = document.getElementById("userRoleSelect");
  if(sel){
    sel.innerHTML = "";
    const rSnap = await getDocs(ROLES_COL);
    rSnap.forEach(d=>{
      const opt = document.createElement("option");
      opt.value = d.id;
      opt.textContent = d.id;
      sel.appendChild(opt);
    });
  }
  startRoleOverview();
}

async function saveWhitelist(){
  if(!perms().canAdmin) return;
  const box = document.getElementById("whitelistBox");
  const lines = (box?.value || "").split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  const unique = Array.from(new Set(lines.map(s=>s.toLowerCase())));
  await setDoc(CFG_SECURITY, { whitelist: unique, updatedAt: serverTimestamp() }, { merge:true });
  alert("Whitelist gespeichert.");
}

async function saveRole(){
  if(!perms().canAdmin) return;
  const name = (document.getElementById("roleName")?.value || "").trim();
  if(!name) return alert("Rollenname fehlt.");
  const canUpload = !!document.getElementById("roleCanUpload")?.checked;
  const canDownload = !!document.getElementById("roleCanDownload")?.checked;
  const canAdmin = !!document.getElementById("roleCanAdmin")?.checked;
  await setDoc(doc(db,"appConfig","global","roles", name), { name, canUpload, canDownload, canAdmin, updatedAt: serverTimestamp() }, { merge:true });
  alert("Rolle gespeichert.");
  await loadAdminUI();
}

async function deleteRole(){
  if(!perms().canAdmin) return;
  const name = (document.getElementById("roleName")?.value || "").trim();
  if(!name) return alert("Rollenname fehlt.");
  if(!confirm("Rolle wirklich l√∂schen?")) return;
  await deleteDoc(doc(db,"appConfig","global","roles", name));
  alert("Rolle gel√∂scht.");
  await loadAdminUI();
}

async function setUserRole(){
  if(!perms().canAdmin) return;
  const email = (document.getElementById("userRoleEmail")?.value || "").trim().toLowerCase();
  const role = (document.getElementById("userRoleSelect")?.value || "").trim();
  if(!email || !email.includes("@")) return alert("Bitte eine g√ºltige E-Mail eingeben.");
  if(!role) return alert("Bitte Rolle w√§hlen.");
  await setDoc(doc(db,"appConfig","global","userRoles", email), { email, role, updatedAt: serverTimestamp() }, { merge:true });
  alert("Benutzerrolle gespeichert.");
}


async function doRegister(){
  const u = $("authUser").value.trim();
  const p = $("authPass").value;
  if(!u || !p) return alert("Bitte Benutzername/Email & Passwort eingeben.");
  const email = normalizeEmail(u);
  try{
    const cred = await createUserWithEmailAndPassword(auth, email, p);
    // optional: store profile doc
    await setDoc(doc(db, "users", cred.user.uid), {
      email,
      createdAt: serverTimestamp()
    }, { merge:true });
    alert("Registriert. Du bist jetzt eingeloggt.");
  } catch(err){
    console.error(err);
    alert("Registrierung fehlgeschlagen: " + explainFirebaseAuthError(err));
  }
}

async function doLogin(){
  const u = $("authUser").value.trim();
  const p = $("authPass").value;
  if(!u || !p) return alert("Bitte Benutzername/Email & Passwort eingeben.");
  const email = normalizeEmail(u);
  try{
    await signInWithEmailAndPassword(auth, email, p);
  } catch(err){
    console.error(err);
    alert("Login fehlgeschlagen: " + explainFirebaseAuthError(err));
  }
}

async function doLogout(){
  try{ await signOut(auth); } catch(e){}
}

// ---------- Branding (fixed) ----------
const APP_BRAND = { name: "Profil Einstellungen", logo: "LD" };
function applyBrand(){
  const n = APP_BRAND.name || "Profil Einstellungen";
  const l = APP_BRAND.logo || "LD";
  const nameEl = document.getElementById("appName");
  const logoEl = document.getElementById("appLogo");
  if(nameEl) nameEl.textContent = n;
  if(logoEl) logoEl.textContent = l;
  // Mirrors
  const mh = document.getElementById("mhAppName"); if(mh) mh.textContent = n;
  const dr = document.getElementById("drawerAppName"); if(dr) dr.textContent = n;
  const dl = document.getElementById("drawerLogo"); if(dl) dl.textContent = l;
}

// ---------- Firestore paths ----------
function requireLogin(){
  if(!state.session?.uid){
    alert("Bitte zuerst einloggen, damit alles √ºber Firebase gespeichert wird.");
    throw new Error("not_logged_in");
  }
  return state.session.uid;
}
function catsCol(uid){ return collection(db, "users", uid, "cats"); }
function itemsCol(uid){ return collection(db, "users", uid, "items"); }
function chatCol(roomId){ return collection(db, "chatRooms", roomId || "global", "messages"); }
function typingCol(roomId){ return collection(db, "chatRooms", roomId || "global", "typing"); }
function filePath(uid, itemId, filename){ return `users/${uid}/files/${itemId}/${filename}`; }

// ---------- Categories (Firestore, realtime) ----------
async function ensureDefaultCats(userId){
  const snap = await getDocs(query(catsCol(userId), orderBy("order","asc")));
  if(!snap.empty) return;
  const defaults = [
    { id:"inbox", name:"Inbox", order: 1 },
    { id:"docs", name:"Dokumente", order: 2 },
    { id:"imgs", name:"Bilder", order: 3 },
    { id:"tours", name:"Tourenpl√§ne", order: 4 },
    { id:"info", name:"Infos/Notizen", order: 5 },
  ];
  for(const c of defaults){
    await setDoc(doc(db, "users", userId, "cats", c.id), {
      name: c.name,
      order: c.order,
      updatedAt: serverTimestamp()
    }, { merge:true });
  }
}

function watchCats(){
  if(state.unsubCats) state.unsubCats();
  const userId = requireLogin();
  const qCats = query(catsCol(userId), orderBy("order","asc"));
  state.unsubCats = onSnapshot(qCats, (snap)=>{
    const arr = [];
    snap.forEach(d=> arr.push({ id: d.id, ...d.data() }));
    state.cats = arr.map(c=>({ id:c.id, name:c.name }));
    renderCats();
    renderItems();
  });
}

async function newCat(){
  const name = prompt("Kategorie/Ordner Name:");
  if(!name) return;
  const userId = requireLogin();
  await addDoc(catsCol(userId), {
    name: name.trim(),
    order: Date.now(),
    updatedAt: serverTimestamp()
  });
}

async function renameCat(id){
  const cat = state.cats.find(c=>c.id===id);
  if(!cat) return;
  const name = prompt("Neuer Name:", cat.name);
  if(!name) return;
  const userId = requireLogin();
  await updateDoc(doc(db, "users", userId, "cats", id), {
    name: name.trim(),
    updatedAt: serverTimestamp()
  });
}

async function deleteCat(id){
  if(!confirm("Kategorie l√∂schen? (Items werden auf 'Inbox' gesetzt)")) return;
  const userId = requireLogin();
  // move items
  const qItems = query(itemsCol(userId), where("catId","==",id));
  const snap = await getDocs(qItems);
  for(const d of snap.docs){
    await updateDoc(d.ref, { catId: "inbox", updatedAt: serverTimestamp() });
  }
  // delete cat
  await deleteDoc(doc(db, "users", userId, "cats", id));
  if(state.selectedCatId === id) state.selectedCatId = "all";
}

function catName(id){
  if(id === "all") return "Alle";
  const c = state.cats.find(x=>x.id===id);
  return c ? c.name : "Inbox";
}

async function renderCats(){
  const el = $("catList");
  if(!el) return;
  el.innerHTML = "";

  const makeBtn = (label, id) => {
const b = document.createElement("button");
    b.className = "btn row";
    b.textContent = label;
    if(state.selectedCatId === id){
      b.style.borderColor = "rgba(77,163,255,.45)";
      b.style.background = "rgba(77,163,255,.10)";
    }
    b.onclick = () => { state.selectedCatId = id; renderCats(); renderItems(); };
    return b;
  };

  el.appendChild(makeBtn("Alle", "all"));

  state.cats.forEach(cat => {
    const row = document.createElement("div");
    row.className = "item";
    row.draggable = true;

    row.addEventListener("dragstart", (e)=> e.dataTransfer.setData("text/cat", cat.id));
    row.addEventListener("dragover", (e)=> { e.preventDefault(); row.style.outline = "2px solid rgba(255,255,255,.12)"; });
    row.addEventListener("dragleave", ()=> row.style.outline = "none");
    row.addEventListener("drop", async (e)=> {
      e.preventDefault(); row.style.outline = "none";
      const dragged = e.dataTransfer.getData("text/cat");
      if(!dragged || dragged === cat.id) return;
      // reordering: swap order field based on timestamp heuristic
      const from = state.cats.findIndex(c=>c.id===dragged);
      const to = state.cats.findIndex(c=>c.id===cat.id);
      if(from<0 || to<0) return;
      const userId = requireLogin();
      const fromId = state.cats[from].id;
      const toId = state.cats[to].id;
      // set "order" to neighbors
      const now = Date.now();
      await updateDoc(doc(db, "users", userId, "cats", fromId), { order: now });
      // Force refresh; ordering by "order" will change (simple but works)
    });

    const meta = document.createElement("div");
    meta.className = "meta";
    const t = document.createElement("div");
    t.className = "title";
    t.textContent = cat.name;
    const d = document.createElement("div");
    d.className = "desc";
    d.textContent = "ID: " + cat.id.slice(0,8);
    meta.appendChild(t); meta.appendChild(d);

    const chip = document.createElement("div");
    chip.className = "chip";
    chip.textContent = "√∂ffnen";
    chip.style.cursor = "pointer";
    chip.onclick = () => { state.selectedCatId = cat.id; renderCats(); renderItems(); };

    const menu = document.createElement("div");
    menu.style.display = "flex";
    menu.style.gap = "8px";
const r = document.createElement("button");
    r.className = "btn small";
    r.textContent = "‚úèÔ∏è";
    r.title = "Umbenennen";
    r.onclick = () => renameCat(cat.id);
const x = document.createElement("button");
    x.className = "btn small danger";
    x.textContent = "üóëÔ∏è";
    x.title = "L√∂schen";
    x.onclick = () => deleteCat(cat.id);

    menu.appendChild(r); menu.appendChild(x);

    row.appendChild(meta);
    row.appendChild(chip);
    row.appendChild(menu);

    // allow dropping files onto category row
    row.addEventListener("dragover", (e)=> {
      if(e.dataTransfer.types.includes("Files")){ e.preventDefault(); row.style.background="rgba(77,163,255,.08)"; }
    });
    row.addEventListener("dragleave", ()=> row.style.background="rgba(0,0,0,.18)");
    row.addEventListener("drop", async (e)=> {
      row.style.background="rgba(0,0,0,.18)";
      if(!e.dataTransfer.files?.length) return;
      e.preventDefault();
      await handleFiles(e.dataTransfer.files, cat.id);
    });

    el.appendChild(row);
  });
}

// ---------- Items (Firestore metadata + Storage blobs) ----------
function guessType(file){
  const t = (file.type || "").toLowerCase();
  if(t.startsWith("image/")) return "img";
  return "doc";
}

function watchItems(){
  if(state.unsubItems) state.unsubItems();
  const userId = requireLogin();
  const qItems = query(itemsCol(userId), orderBy("createdAt","desc"));
  state.unsubItems = onSnapshot(qItems, (snap)=>{
    const arr = [];
    snap.forEach(d=> {
      const data = d.data();
      arr.push({
        id: d.id,
        ...data,
        // createdAt can be Firestore Timestamp
        createdAt: data.createdAt?.toMillis ? data.createdAt.toMillis() : (data.createdAt || Date.now())
      });
    });
    state.items = arr;
    renderItems();
  });
}

async function handleFiles(fileList, catId){
  if(STORAGE_DISABLED){
    return alert("Uploads sind deaktiviert, weil Firebase Storage im Spark Plan nicht verf√ºgbar ist. (Admin: Upgrade auf Blaze oder externes File-Hosting nutzen)");
  }
  if(!perms().canUpload){
    return alert("Du hast keine Upload-Rechte (Rolle).");
  }
  const userId = requireLogin();
  const files = Array.from(fileList);
  for(const f of files){
    const itemId = uid();
    const path = filePath(userId, itemId, f.name);
        const item = {
      kind: "file",
      type: guessType(f),
      name: f.name,
      mime: f.type || "application/octet-stream",
      size: f.size,
      catId: catId || (state.selectedCatId !== "all" ? state.selectedCatId : "inbox"),
      createdAt: serverTimestamp(),
      notes: "",
      storagePath: null
    };
    await setDoc(doc(db, "users", userId, "items", itemId), item, { merge:true });
  }
}

async function createNote(){
  const userId = requireLogin();
  const title = prompt("Titel der Info/Notiz:");
  if(!title) return;
  const text = prompt("Inhalt (kurz):") || "";
  const itemId = uid();
  await setDoc(doc(db, "users", userId, "items", itemId), {
    kind: "note",
    type: "note",
    name: title.trim(),
    mime: "text/plain",
    size: text.length,
    catId: state.selectedCatId !== "all" ? state.selectedCatId : "info",
    createdAt: serverTimestamp(),
    notes: text,
    storagePath: null
  }, { merge:true });
}

function matchesSearch(item, q){
  if(!q) return true;
  q = q.toLowerCase();
  return [
    item.name,
    item.notes || "",
    item.mime || "",
    item.type || "",
    catName(item.catId)
  ].some(v => (v || "").toLowerCase().includes(q));
}

function matchesFilter(item){
  if(state.selectedCatId !== "all" && item.catId !== state.selectedCatId) return false;
  if(state.typeFilter === "all") return true;
  if(state.typeFilter === "doc") return item.kind === "file" && item.type === "doc";
  if(state.typeFilter === "img") return item.kind === "file" && item.type === "img";
  return true;
}

async function renderItems(){
  const grid = $("fileGrid");
  const q = state.search.trim();
  const filtered = (state.items||[])
    .filter(it => matchesFilter(it))
    .filter(it => matchesSearch(it, q));

  grid.innerHTML = "";

  if(!filtered.length){
    const empty = document.createElement("div");
    empty.className = "fileCard";
    empty.style.gridColumn = "1 / -1";
    empty.innerHTML = `
      <div class="name">Keine Treffer</div>
      <div class="small">${state.session?.uid ? "Versuche andere Suche/Kategorie oder lade Dateien hoch." : "Bitte einloggen, um Firebase-Daten zu sehen."}</div>
    `;
    grid.appendChild(empty);
    return;
  }

  filtered.forEach(it => {
    const card = document.createElement("div");
    card.className = "fileCard";
    card.draggable = true;

    card.addEventListener("dragstart", (e)=> e.dataTransfer.setData("text/item", it.id));
    card.addEventListener("dragover", (e)=> e.preventDefault());

    const top = document.createElement("div");
    top.className = "row";
    const name = document.createElement("div");
    name.className = "name";
    name.textContent = it.kind === "note" ? "üìù " + it.name : (it.type === "img" ? "üñºÔ∏è " : "üìÑ ") + it.name;
    const badge = document.createElement("div");
    badge.className = "chip";
    badge.textContent = catName(it.catId);
    top.appendChild(name);
    top.appendChild(badge);

    const mid = document.createElement("div");
    mid.className = "small";
    if(it.kind === "note"){
      mid.textContent = (it.notes || "").slice(0, 90) || "‚Äî";
    } else {
      const kb = (Number(it.size||0)/1024).toFixed(1);
      mid.textContent = `${it.mime} ‚Ä¢ ${kb} KB ‚Ä¢ ${fmtDate(it.createdAt)}`;
    }

    const actions = document.createElement("div");
    actions.className = "actions";

const btnOpen = document.createElement("button");
    btnOpen.className = "btn small primary";
    btnOpen.textContent = it.kind === "note" ? "Ansehen" : "√ñffnen";
    btnOpen.onclick = () => openItem(it);

const btnMove = document.createElement("button");
    btnMove.className = "btn small";
    btnMove.textContent = "Verschieben";
    btnMove.onclick = () => moveItem(it);

const btnNote = document.createElement("button");
    btnNote.className = "btn small";
    btnNote.textContent = "Notiz";
    btnNote.onclick = () => editNotes(it);

const btnDel = document.createElement("button");
    btnDel.className = "btn small danger";
    btnDel.textContent = "L√∂schen";
    btnDel.onclick = async () => {
      if(!confirm("Wirklich l√∂schen?")) return;
      const userId = requireLogin();
            await deleteDoc(doc(db, "users", userId, "items", it.id));
    };

    actions.appendChild(btnOpen);
    actions.appendChild(btnMove);
    actions.appendChild(btnNote);
    actions.appendChild(btnDel);

    card.appendChild(top);
    card.appendChild(mid);
    card.appendChild(actions);

    grid.appendChild(card);
  });
}

async function openItem(it){
  if(it.kind === "note"){
    alert(`${it.name}\n\n${it.notes || ""}`);
    return;
  }
  if(!perms().canDownload){
    return alert("Du hast keine Download-Rechte (Rolle).");
  }
  if(STORAGE_DISABLED){
    return alert("Download ist deaktiviert (kein Firebase Storage im Spark Plan).");
  }
  return alert("Datei-Download ist aktuell nicht eingerichtet.");
}

async function moveItem(it){
  const options = state.cats.map(c=> `${c.id}:${c.name}`).join("\n");
  const dest = prompt("Ziel-Kategorie ID eingeben:\n" + options, it.catId);
  if(!dest) return;
  const userId = requireLogin();
  await updateDoc(doc(db, "users", userId, "items", it.id), {
    catId: dest.trim(),
    updatedAt: serverTimestamp()
  });
}

async function editNotes(it){
  const val = prompt("Notiz/Info (f√ºr Suche hilfreich):", it.notes || "");
  if(val === null) return;
  const userId = requireLogin();
  await updateDoc(doc(db, "users", userId, "items", it.id), {
    notes: val,
    updatedAt: serverTimestamp()
  });
}

// ---------- Drag & Drop Upload zone ----------
async function setupDropzone(){
  const dz = $("dropzone");
  dz.addEventListener("dragover", (e) => {
    e.preventDefault();
    dz.classList.add("drag");
  });
  dz.addEventListener("dragleave", () => dz.classList.remove("drag"));
  dz.addEventListener("drop", async (e) => {
    e.preventDefault();
    dz.classList.remove("drag");
    if(e.dataTransfer.files?.length){
      try{ await handleFiles(e.dataTransfer.files); } catch(_e){}
    }
  });
}

// ---------- Search ----------
function setupSearch(){
  $("searchInput").addEventListener("input", (e) => {
    state.search = e.target.value;
    renderItems();
  });
  $("typeFilter").addEventListener("change", (e) => {
    state.typeFilter = e.target.value;
    renderItems();
  });
}


function scrollChatBottom(force=false){
  const log = document.getElementById("chatLog");
  if(!log) return;
  if(force || shouldAutoScroll(log)) scrollToBottom(log);
}

// ---------- Chat (Firestore realtime) ----------
async function watchChat(){
  if(state.unsubChat) state.unsubChat();
    if(state.unsubTyping) state.unsubTyping();
  const userId = requireLogin();
  const roomId = state.chatRoom || "global";
  const qChat = query(chatCol(roomId), orderBy("at","asc"));
  state.unsubChat = onSnapshot(qChat, (snap)=>{
    const log = $("chatLog");
    if(!log) return;
    const keepBottom = shouldAutoScroll(log);
    log.innerHTML = "";

    let lastDateKey = null;

    snap.docs.slice(-200).forEach(d=>{
      const m = d.data() || {};
      const atMs = m.at?.toMillis ? m.at.toMillis() : (m.atMs || m.at || Date.now());
      const dt = new Date(atMs);
      const dateKey = dt.toLocaleDateString("de-CH");

      if(dateKey !== lastDateKey){
        lastDateKey = dateKey;
        const sep = document.createElement("div");
        sep.className = "dateSep";
        sep.textContent = dateKey;
        log.appendChild(sep);
      }

      const b = document.createElement("div");
      b.className = "bubble " + ((m.uid && m.uid === userId) ? "me" : "");
      b.innerHTML = `<div>${escapeHtml(m.text)}</div><div class="t">${escapeHtml(m.user || "User")} ‚Ä¢ ${fmtDate(atMs)}</div>`;

      var canDelete = perms().canAdmin || (m.uid && m.uid === userId);
      if(canDelete){
        const del = document.createElement("button");
        del.className = "delMsgBtn";
        del.type = "button";
        del.textContent = "L√∂schen";
        del.addEventListener("click", async (ev)=>{
          ev.stopPropagation();
          if(!confirm("Nachricht wirklich l√∂schen?")) return;
          try{
            await deleteDoc(doc(db, "chatRooms", roomId, "messages", d.id));
          }catch(e){
            console.error(e);
            alert("L√∂schen fehlgeschlagen: " + (e?.message||e));
          }
        });
        b.appendChild(del);
      }

      log.appendChild(b);
    });

    if(keepBottom){
      scrollToBottom(log);
    }
  });
}


function watchTyping(){
  if(state.unsubTyping) state.unsubTyping();
  const userId = requireLogin();
  const roomId = state.chatRoom || "global";
  const qT = query(typingCol(roomId), where("typing","==",true));
  state.unsubTyping = onSnapshot(qT, (snap)=>{
    const line = document.getElementById("typingLine");
    if(!line) return;
    const now = Date.now();
    const names = [];
    snap.forEach(docu=>{
      const t = docu.data() || {};
      if(t.uid === userId) return;
      const atMs = t.at?.toMillis ? t.at.toMillis() : (t.atMs || 0);
      if(atMs && (now - atMs) > 12_000) return; // stale
      names.push(t.user || t.displayName || t.email || "User");
    });
    const uniq = Array.from(new Set(names)).slice(0, 3);
    if(!uniq.length){
      line.classList.add("hidden");
      return;
    }
    line.classList.remove("hidden");
    if(uniq.length === 1) line.textContent = `üü¢ ${uniq[0]} tippt‚Ä¶`;
    else line.textContent = `üü¢ ${uniq.length} Personen tippen‚Ä¶`;
  });
}

async function setMyTyping(isTyping){
  if(!state.session?.uid) return;
  const roomId = state.chatRoom || "global";
  const ref = doc(db, "chatRooms", roomId, "typing", state.session.uid);
  const user = state.session?.user || state.profile?.displayName || displayNameFromEmail(state.session?.email);
  await setDoc(ref, {
    uid: state.session.uid,
    user,
    email: state.session.email || "",
    typing: !!isTyping,
    at: serverTimestamp(),
    atMs: Date.now()
  }, { merge:true });
}

function bindTypingUI(){
  const inp = document.getElementById("chatText");
  if(!inp) return;

  const bump = ()=>{
    // mark typing true, then schedule auto-off
    setMyTyping(true).catch(()=>{});
    if(state.typingTimer) clearTimeout(state.typingTimer);
    state.typingTimer = setTimeout(()=> setMyTyping(false).catch(()=>{}), 4000);
  };

  inp.addEventListener("input", bump);
  inp.addEventListener("keydown", (e)=>{ if(e.key.length === 1) bump(); });
  inp.addEventListener("blur", ()=> setMyTyping(false).catch(()=>{}));
}

async function sendChat(){
  const inp = $("chatText");
  const text = (inp?.value || "").trim();
  if(!text) return;

  const userId = requireLogin();
  const roomId = state.chatRoom || "global";
  const user = state.session?.user || "User";

  // 1) Write message to Firestore (keep this awaited for correctness)
  const writeP = addDoc(chatCol(roomId), {
    text,
    user,
    uid: userId,
    at: serverTimestamp(),
    atMs: Date.now()
  });

  // 2) Trigger push via Netlify Function ASAP (do not wait for Firestore write)
  //    Also cache the ID token so we don't refresh it on every message (reduces latency).
  (async ()=>{
    try{
      const cur = auth?.currentUser || null;
      if(!cur) return;

      const now = Date.now();
      const cache = (window.__idTokenCache ||= { token: null, expMs: 0 });
      let idToken = cache.token;

      // Refresh if missing or expiring in <60s
      if(!idToken || (cache.expMs && (cache.expMs - now) < 60_000)){
        idToken = await cur.getIdToken();
        // Decode JWT exp (seconds) -> ms
        try{
          const b64 = idToken.split(".")[1].replace(/-/g,"+").replace(/_/g,"/");
          const json = decodeURIComponent(atob(b64).split("").map(c=>"%"+("00"+c.charCodeAt(0).toString(16)).slice(-2)).join(""));
          const payload = JSON.parse(json);
          cache.token = idToken;
          cache.expMs = (payload.exp ? payload.exp*1000 : (now + 45*60*1000));
        }catch(_e){
          cache.token = idToken;
          cache.expMs = now + 45*60*1000; // fallback
        }
      }

      fetch("/.netlify/functions/push_chat", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          ...(idToken ? { "Authorization": "Bearer " + idToken } : {})
        },
        body: JSON.stringify({ roomId, text, user, uid: userId }),
        keepalive: true
      }).catch(()=>{});
    }catch(_e){}
  })();

  // UI cleanup immediately (feels snappy)
  if(inp) inp.value = "";
  setMyTyping(false).catch(()=>{});

  // Keep behavior consistent
  try{ scrollChatBottom(true); }catch(_e){}

  // Ensure write completes
  await writeP;
}

// ---------- Rangliste (Firestore realtime) ----------

// ---------- F√§lle + Rangliste (Firestore realtime) ----------
// Global collection for cases. Each document represents one reported case.
const CASES_COL = collection(db, "cases");
// Per-user subcollection for services ("Dienste")
function servicesCol(uid){ return collection(db, "users", uid, "services"); }
 
// doc fields: { reporterUid, reporterEmail, reporterName, place, occurredAt, createdAt }

function toLocalDateTimeStr(ms){
  try{
    const d = new Date(ms);
    const ds = d.toLocaleDateString("de-CH");
    const ts = d.toLocaleTimeString("de-CH", { hour:"2-digit", minute:"2-digit" });
    return `${ds} ‚Ä¢ ${ts}`;
  }catch(_e){ return ""; }
}

function computeRankingFromCases(casesArr){
  const map = new Map(); // key: reporterUid (fallback reporterName)
  for(const c of (casesArr||[])){
    const key = c.reporterUid || c.reporterName || "unknown";
    const cur = map.get(key) || {
      reporterUid: c.reporterUid || "",
      reporterName: c.reporterName || "Unbekannt",
      reporterEmail: (c.reporterEmail || "").toLowerCase(),
      count: 0,
      lastAt: 0
    };
    cur.count += 1;
    const at = c.occurredAtMs || 0;
    if(at > (cur.lastAt||0)) cur.lastAt = at;
    // prefer non-empty name/email
    if(c.reporterName) cur.reporterName = c.reporterName;
    if(c.reporterEmail) cur.reporterEmail = (c.reporterEmail || "").toLowerCase();
    map.set(key, cur);
  }
  const rows = Array.from(map.values());
  rows.sort((a,b)=> (b.count||0) - (a.count||0) || (b.lastAt||0) - (a.lastAt||0));
  return rows;
}

function renderRanking(){
  const list = document.getElementById("rankingList");
  if(!list) return;

  list.innerHTML = "";

  if(!state.session?.uid){
    list.innerHTML = `<div class="fileCard"><div class="name">Bitte einloggen</div><div class="small">Rangliste wird nach Login live aus Firebase geladen.</div></div>`;
    return;
  }

  const rows = state.rankings || [];
  if(!rows.length){
    list.innerHTML = `<div class="fileCard"><div class="name">Noch keine F√§lle</div><div class="small">Sobald jemand F√§lle eintr√§gt, erscheinen hier Name & Anzahl.</div></div>`;
    return;
  }

  rows.forEach((r, i)=>{
    const card = document.createElement("div");
    card.className = "item";
    card.style.padding = "12px";
    const subtitle = r.lastAt ? ("Letzter Fall: " + escapeHtml(toLocalDateTimeStr(r.lastAt))) : "";
    const medal = (i===0 ? "ü•á" : i===1 ? "ü•à" : i===2 ? "ü•â" : (i+1) + ".");
    card.innerHTML = `
      <div class="meta" style="min-width:0; flex:1;">
        <div class="title">${medal} ${escapeHtml(r.reporterName || "User")}</div>
        <div class="desc">${escapeHtml(r.reporterEmail || subtitle || "")}</div>
      </div>
      <div class="chip" style="font-weight:900; color: var(--text);">${Number(r.count||0)} F√§lle</div>
    `;
    list.appendChild(card);
  });
}

async function renderMyCases(){
  const list = document.getElementById("caseList");
  if(!list) return;

  list.innerHTML = "";

  if(!state.session?.uid){
    list.innerHTML = `<div class="fileCard"><div class="name">Bitte einloggen</div><div class="small">F√§lle werden erst nach Login gespeichert.</div></div>`;
    return;
  }

  const rows = (state.cases || []).filter(c => c.reporterUid === state.session.uid);
  if(!rows.length){
    list.innerHTML = `<div class="fileCard"><div class="name">Noch keine F√§lle gespeichert</div><div class="small">Trage oben einen Fall ein und klicke ‚ÄûSpeichern‚Äú.</div></div>`;
    return;
  }

  rows.forEach((c)=>{
    const card = document.createElement("div");
    card.className = "item";
    card.style.padding = "12px";
    const when = c.occurredAtMs ? toLocalDateTimeStr(c.occurredAtMs) : "";
    card.innerHTML = `
  <div class="caseMeta">
    <div class="caseTitle">${escapeHtml(c.place || "‚Äî")}</div>
    <div class="caseSub">${escapeHtml(when)}${c.reporterName ? " ‚Ä¢ " + escapeHtml(c.reporterName) : ""}</div>
  </div>
  <button class="btn small danger" type="button" aria-label="Fall l√∂schen" title="Fall l√∂schen">üóëÔ∏è</button>
`;
const btnDel = card.querySelector("button");
    btnDel.onclick = async ()=>{
      if(!confirm("Fall wirklich l√∂schen?")) return;
      try{
        requireLogin();
        // Only allow deleting own cases client-side
        if(c.reporterUid !== state.session.uid) return alert("Du kannst nur deine eigenen F√§lle l√∂schen.");
        await deleteDoc(doc(db, "cases", c.id));
      }catch(e){
        console.error(e);
        alert("L√∂schen fehlgeschlagen: " + (e?.message||e));
      }
    };
    list.appendChild(card);
  });
}

function watchCases(){
  if(state.unsubCases) state.unsubCases();
      if(state.unsubMyProfile) state.unsubMyProfile();
// global -> needs login
  requireLogin();

  const qCases = query(CASES_COL, orderBy("occurredAt","desc"));
  state.unsubCases = onSnapshot(qCases, (snap)=>{
    const arr = [];
    snap.forEach(d=>{
      const data = d.data() || {};
      const occurredAtMs = data.occurredAt?.toMillis ? data.occurredAt.toMillis() : (data.occurredAt || 0);
      arr.push({ id: d.id, ...data, occurredAtMs });
    });
    state.cases = arr;
    state.rankings = computeRankingFromCases(arr);

    renderMyCases();
    renderRanking();
  }, (err)=>{
    console.error(err);
  });
}

// ---------- Dienste (Service Start/Ende) ----------
let serviceStartMs = 0;
let serviceTimer = null;

function pad2(n){ return String(n).padStart(2,"0"); }
function msToHHMM(ms){
  const d = new Date(ms);
  return pad2(d.getHours()) + ":" + pad2(d.getMinutes());
}
function hhmmToDate(dateStr, hhmm){
  // dateStr: YYYY-MM-DD, hhmm: HH:MM
  const iso = `${dateStr}T${hhmm}:00`;
  const dt = new Date(iso);
  return isNaN(dt.getTime()) ? null : dt;
}
function durationStr(sec){
  sec = Math.max(0, Number(sec||0));
  const h = Math.floor(sec/3600);
  const m = Math.floor((sec%3600)/60);
  const s = Math.floor(sec%60);
  return `${pad2(h)}:${pad2(m)}:${pad2(s)}`;
}

async function renderServices(){
  const list = document.getElementById("serviceList");
  if(!list) return;

  list.innerHTML = "";

  if(!state.session?.uid){
    list.innerHTML = `<div class="fileCard"><div class="name">Bitte einloggen</div><div class="small">Dienste werden erst nach Login gespeichert.</div></div>`;
    return;
  }

  const rows = (state.services || []);
  if(!rows.length){
    list.innerHTML = `<div class="fileCard"><div class="name">Noch keine Dienste</div><div class="small">Oben Dienstbeginn/Dienstende erfassen und speichern.</div></div>`;
    return;
  }

  rows.forEach((s)=>{
    const card = document.createElement("div");
    card.className = "item";
    card.style.padding = "12px";

    const date = s.date || "";
    const pn = s.personalNumber || "‚Äî";
    const name = s.name || "‚Äî";
    const start = s.startAtMs ? msToHHMM(s.startAtMs) : (s.startTime || "‚Äî");
    const end = s.endAtMs ? msToHHMM(s.endAtMs) : (s.endTime || "‚Äî");
    const dur = (s.durationSec != null) ? durationStr(s.durationSec) : "‚Äî";

    card.innerHTML = `
      <div class="meta" style="min-width:0; flex:1;">
        <div class="title">${escapeHtml(date)} ‚Ä¢ ${escapeHtml(name)} (${escapeHtml(pn)})</div>
        <div class="desc">Beginn: ${escapeHtml(start)} ‚Ä¢ Ende: ${escapeHtml(end)} ‚Ä¢ Dauer: ${escapeHtml(dur)}</div>
      </div>
      <button class="btn small danger" type="button" aria-label="Dienst l√∂schen" title="Dienst l√∂schen">üóëÔ∏è</button>
    `;

    const btnDel = card.querySelector("button");
    btnDel.onclick = async ()=>{
      if(!confirm("Diesen Dienst wirklich l√∂schen?")) return;
      try{
        const uid = requireLogin();
        await deleteDoc(doc(db, "users", uid, "services", s.id));
      }catch(e){
        console.error(e);
        alert("L√∂schen fehlgeschlagen: " + (e?.message||e));
      }
    };

    list.appendChild(card);
  });
}

function watchServices(){
  if(state.unsubServices) state.unsubServices();
  const uid = requireLogin();
  const qS = query(servicesCol(uid), orderBy("startAt","desc"));
  state.unsubServices = onSnapshot(qS, (snap)=>{
    const arr = [];
    snap.forEach(d=>{
      const data = d.data() || {};
      const startAtMs = data.startAt?.toMillis ? data.startAt.toMillis() : (data.startAtMs || 0);
      const endAtMs = data.endAt?.toMillis ? data.endAt.toMillis() : (data.endAtMs || 0);
      arr.push({ id: d.id, ...data, startAtMs, endAtMs });
    });
    state.services = arr;
    renderServices();
  }, (err)=> console.error(err));
}

function stopServiceTimer(){
  if(serviceTimer) clearInterval(serviceTimer);
  serviceTimer = null;
}

function updateServiceRunningLine(){
  const line = document.getElementById("serviceRunningLine");
  if(!line) return;
  if(!serviceStartMs){
    line.textContent = "‚Äî";
    return;
  }
  const sec = Math.floor((Date.now() - serviceStartMs) / 1000);
  line.textContent = "L√§uft: " + durationStr(sec);
}
function updateServicePreviewLine(){
  const line = document.getElementById("serviceRunningLine");
  if(!line) return;

  const date = (document.getElementById("serviceDate")?.value || "").trim();
  const startHH = (document.getElementById("serviceStartTime")?.value || "").trim();
  const endHH = (document.getElementById("serviceEndTime")?.value || "").trim();

  if(!date || !startHH){
    line.textContent = "‚Äî";
    return;
  }

  // If end is not set yet, just show start time
  if(!endHH){
    line.textContent = "Beginn: " + startHH;
    return;
  }

  const startDt = hhmmToDate(date, startHH);
  const endDt = hhmmToDate(date, endHH);
  if(!startDt || !endDt){
    line.textContent = "‚Äî";
    return;
  }

  let endMs = endDt.getTime();
  const startMs = startDt.getTime();
  if(endMs < startMs){
    endMs += 24*60*60*1000;
  }
  const durationSec = Math.round((endMs - startMs)/1000);
  line.textContent = "Dauer: " + durationStr(durationSec);
}


function clearServiceForm(){
  const now = new Date();
  const d = now.toISOString().slice(0,10);

  const dateEl = document.getElementById("serviceDate");
  const pnEl = document.getElementById("servicePN");
  const nameEl = document.getElementById("serviceName");
  const startEl = document.getElementById("serviceStartTime");
  const endWrap = document.getElementById("serviceEndWrap");
  const endEl = document.getElementById("serviceEndTime");

  if(dateEl) dateEl.value = d;
  if(pnEl) pnEl.value = (pnEl.value || "").trim(); // keep if user already typed
  if(nameEl) nameEl.value = (state.profile?.displayName || state.session?.user || displayNameFromEmail(state.session?.email) || "");
  if(startEl){ startEl.value = ""; startEl.disabled = true; }
  if(endEl){ endEl.value = ""; endEl.disabled = false; }

  if(endWrap) endWrap.classList.add("hidden");

  serviceStartMs = 0;
  stopServiceTimer();
  updateServiceRunningLine();

  // buttons
  const bStart = document.getElementById("btnServiceStart");
  const bEnd = document.getElementById("btnServiceEnd");
  const bSave = document.getElementById("btnServiceSave");
  if(bStart) bStart.disabled = false;
  if(bEnd) bEnd.disabled = true;
  if(bSave) bSave.disabled = true;

  const hint = document.getElementById("serviceStatusHint");
  if(hint) hint.textContent = "Tipp: Dienstbeginn starten ‚Üí danach Dienstende setzen ‚Üí speichern.";
}

async function startService(){
  requireLogin();

  const date = (document.getElementById("serviceDate")?.value || "").trim();
  const pn = (document.getElementById("servicePN")?.value || "").trim();
  const name = (document.getElementById("serviceName")?.value || "").trim();
  if(!date) return alert("Bitte Datum w√§hlen.");
  if(!pn) return alert("Bitte Personalnummer eingeben.");
  if(!name) return alert("Bitte Name eingeben.");

  serviceStartMs = Date.now();

  await setInService(true);
  const startEl = document.getElementById("serviceStartTime");
  if(startEl){
    startEl.value = msToHHMM(serviceStartMs);
    startEl.disabled = true;
  }

  // show UI state
  document.getElementById("btnServiceStart").disabled = true;
  document.getElementById("btnServiceEnd").disabled = false;
  document.getElementById("btnServiceSave").disabled = true;
  document.getElementById("serviceEndWrap")?.classList.add("hidden");

  const hint = document.getElementById("serviceStatusHint");
  if(hint) hint.textContent = "Dienst l√§uft‚Ä¶ Dr√ºcke ‚ÄûDienstende‚Äú, wenn du fertig bist.";

  updateServiceRunningLine();
  stopServiceTimer();
  serviceTimer = setInterval(updateServiceRunningLine, 1000);
}

function endService(){
  if(!serviceStartMs) return;
  const now = Date.now();
  const endWrap = document.getElementById("serviceEndWrap");
  const startEl = document.getElementById("serviceStartTime");
  const endEl = document.getElementById("serviceEndTime");

  // show end input + set default end time
  if(endWrap) endWrap.classList.remove("hidden");
  if(endEl && !endEl.value){
    endEl.value = msToHHMM(now);
  }

  // stop running timer (from "Dienstbeginn") and allow manual corrections
  stopServiceTimer();
  if(startEl) startEl.disabled = false;
  if(endEl) endEl.disabled = false;

  document.getElementById("btnServiceEnd").disabled = true;
  document.getElementById("btnServiceSave").disabled = false;

  // show a preview duration instead of "l√§uft"
  updateServicePreviewLine();

  const hint = document.getElementById("serviceStatusHint");
  if(hint) hint.textContent = "Dienstbeginn & Dienstende pr√ºfen/√§ndern ‚Üí dann ‚ÄûSpeichern‚Äú.";
}

async function saveService(){
  requireLogin();

  const date = (document.getElementById("serviceDate")?.value || "").trim();
  const pn = (document.getElementById("servicePN")?.value || "").trim();
  const name = (document.getElementById("serviceName")?.value || "").trim();
  const startHH = (document.getElementById("serviceStartTime")?.value || "").trim();
  const endHH = (document.getElementById("serviceEndTime")?.value || "").trim();

  if(!date) return alert("Bitte Datum w√§hlen.");
  if(!pn) return alert("Bitte Personalnummer eingeben.");
  if(!name) return alert("Bitte Name eingeben.");
  if(!serviceStartMs || !startHH) return alert("Bitte zuerst ‚ÄûDienstbeginn‚Äú dr√ºcken.");
  if(!endHH) return alert("Bitte Dienstende (Zeit) eingeben.");

  const startDt = hhmmToDate(date, startHH);
  const endDt = hhmmToDate(date, endHH);
  if(!startDt || !endDt) return alert("Datum/Zeit ist ung√ºltig.");

  // If end is before start, assume it ended next day
  let endMs = endDt.getTime();
  const startMs = startDt.getTime();
  if(endMs < startMs){
    endMs += 24*60*60*1000;
  }
  const durationSec = Math.round((endMs - startMs)/1000);

  const uid = state.session.uid;
  await addDoc(servicesCol(uid), {
    date,
    personalNumber: pn,
    name,
    startTime: startHH,
    endTime: endHH,
    startAt: Timestamp.fromDate(new Date(startMs)),
    endAt: Timestamp.fromDate(new Date(endMs)),
    durationSec,
    createdAt: serverTimestamp()
  });
    await setInService(false);

  
  // Trigger Power Automate -> Teams (Adaptive Card)
  notifyTeamsDienstzeit({
    datum: date,
    personalnummer: pn,
    name: name,
    dienstbeginn: startHH,
    dienstende: endHH
  });
clearServiceForm();
      // Cleanup active-duty listener
      if(state.unsubActiveDuty) state.unsubActiveDuty();
      state.unsubActiveDuty = null;
  alert("Dienst gespeichert.");
}

function clearCaseForm(){
  const now = new Date();
  const d = now.toISOString().slice(0,10);
  const t = now.toTimeString().slice(0,5);
  const nameEl = document.getElementById("caseName");
  const placeEl = document.getElementById("casePlace");
  const dateEl = document.getElementById("caseDate");
  const timeEl = document.getElementById("caseTime");

  if(nameEl) nameEl.value = state.profile?.displayName || state.session?.user || displayNameFromEmail(state.session?.email) || "";
  if(placeEl) placeEl.value = "";
  if(dateEl) dateEl.value = d;
  if(timeEl) timeEl.value = t;
}

async function saveCase(){
  requireLogin();

  const name = (document.getElementById("caseName")?.value || "").trim();
  const place = (document.getElementById("casePlace")?.value || "").trim();
  const date = (document.getElementById("caseDate")?.value || "").trim();
  const time = (document.getElementById("caseTime")?.value || "").trim();

  if(!name) return alert("Bitte Name eingeben.");
  if(!place) return alert("Bitte Ort eingeben.");
  if(!date) return alert("Bitte Datum w√§hlen.");
  if(!time) return alert("Bitte Zeit w√§hlen.");

  const iso = `${date}T${time}:00`;
  const dt = new Date(iso);
  if(isNaN(dt.getTime())) return alert("Datum/Zeit ist ung√ºltig.");

  const payload = {
    reporterUid: state.session.uid,
    reporterEmail: (state.session.email || "").toLowerCase(),
    reporterName: name,
    place,
    occurredAt: Timestamp.fromDate(dt),
    createdAt: serverTimestamp()
  };

  await addDoc(CASES_COL, payload);
  clearCaseForm();
  alert("Fall gespeichert.");
}

// ---------- Notifications (Web) ----------

// ---------- PUSH (FCM) ----------
const VAPID_PUBLIC_KEY = "BM4ge6OlpY_fY9n0P5yIBlwb9TlFomqrqPF1ZE-LScjUIXqydXU8P_6zDNq7RGGkctkFmg0Bd4rqgOoRxplYqB8";

function setPushUiStatus(msg, ok=true){
  const el = $("pushStatus");
  if(!el) return;
  el.textContent = msg;
  el.style.color = ok ? "rgba(150,255,190,.95)" : "rgba(255,130,130,.95)";
}

async function enablePushFCM(){
  if(!("Notification" in window)) {
    alert("Benachrichtigungen werden vom Browser nicht unterst√ºtzt.");
    return;
  }

  const perm = await Notification.requestPermission();
  if(perm !== "granted") {
    setPushUiStatus("Benachrichtigungen nicht erlaubt.", false);
    return;
  }

  const uid = (typeof requireLogin === "function") ? requireLogin() : (auth?.currentUser?.uid || null);
  if(!uid) {
    alert("Bitte zuerst einloggen.");
    return;
  }

  let supported = true;
  try{ supported = await messagingIsSupported(); }catch(_){
    supported = true;
  }
  if(!supported) {
    setPushUiStatus("Push wird auf diesem Ger√§t/Browser nicht unterst√ºtzt.", false);
    return;
  }

  const reg = await swReady;
  if(!reg) {
    setPushUiStatus("Service Worker nicht aktiv. Pr√ºfe, ob /firebase-messaging-sw.js erreichbar ist.", false);
    return;
  }

  try {
    const messaging = getMessaging(app);
    const token = await getToken(messaging, {
      vapidKey: VAPID_PUBLIC_KEY,
      serviceWorkerRegistration: reg
    });

    if(!token) {
      setPushUiStatus("Kein Token erhalten (getToken = null).", false);
      return;
    }

    await setDoc(doc(db, "users", uid), {
      fcmTokens: { [token]: true },
      updatedAt: serverTimestamp()
    }, { merge: true });

    localStorage.setItem("fcmToken:last:" + uid, token);

    // Token nur f√ºr Admin anzeigen
    const t = $("pushTokenPreview");
    if(t && isAdminUser()) t.value = token;

    setPushUiStatus("‚úÖ Push aktiviert & Token gespeichert.", true);
    try{ applyPushUiVisibility(); checkPushState(); }catch(_e){}
  } catch(e) {
    console.error(e);
    setPushUiStatus("Push aktivieren fehlgeschlagen: " + (e?.message || e), false);
  }
}

async function disablePushFCM(){
  try {
    const uid = (typeof requireLogin === "function") ? requireLogin() : (auth?.currentUser?.uid || null);
    if(!uid) { alert("Bitte zuerst einloggen."); return; }

    let supported = true;
    try{ supported = await messagingIsSupported(); }catch(_){
      supported = true;
    }
    if(!supported) {
      setPushUiStatus("Push wird auf diesem Ger√§t/Browser nicht unterst√ºtzt.", false);
      return;
    }

    const messaging = getMessaging(app);
    await deleteToken(messaging);

    const last = localStorage.getItem("fcmToken:last:" + uid) || "";
    localStorage.removeItem("fcmToken:last:" + uid);
    const t = $("pushTokenPreview");
    if(t) t.value = "";

    setPushUiStatus("Push deaktiviert (Token im Browser gel√∂scht).", true);
    try{ applyPushUiVisibility(); checkPushState(); }catch(_e){}

    if(last) {
      try {
        await updateDoc(doc(db, "users", uid), {
          ["fcmTokens." + last]: deleteField(),
          updatedAt: serverTimestamp()
        });
      } catch(_) {}
    }
  } catch(e) {
    console.error(e);
    setPushUiStatus("Push deaktivieren fehlgeschlagen: " + (e?.message || e), false);
  }
}

(async ()=>{
  try {
    let supported = true;
    try{ supported = await messagingIsSupported(); }catch(_){
      supported = true;
    }
    if(!supported) return;
    const messaging = getMessaging(app);
    onMessage(messaging, (payload)=>{
      console.log("[FCM foreground]", payload);
    });
  } catch(_) {}
})();

document.addEventListener("DOMContentLoaded", ()=>{
  const ep = $("btnEnablePush"); if(ep) ep.addEventListener("click", enablePushFCM);
  const dp = $("btnDisablePush"); if(dp) dp.addEventListener("click", disablePushFCM);
});


async function notify(){
  if(!("Notification" in window)){
    alert("Notifications werden vom Browser nicht unterst√ºtzt.");
    return;
  }
  const perm = await Notification.requestPermission();
  if(perm !== "granted"){
    alert("Benachrichtigungen nicht erlaubt.");
    return;
  }
  new Notification($("appName").textContent || "Profil Einstellungen", {
    body: "Benachrichtigung (lokal) ‚Äì sp√§ter auch via Server/SMS m√∂glich.",
  });
}

// ---------- Mobile Tabs ----------

function setMobileView(view){
  const isMobile = window.matchMedia("(max-width: 980px)").matches;
  // Auf Desktop nutzen wir ebenfalls ‚ÄûSingle-View‚Äú, damit es √ºbersichtlich ist.
  const compact = !isMobile;
  state.mobileView = view;

  

  // --- View CSS helper classes (for mobile scrolling rules etc.) ---
  document.body.classList.remove("view-start","view-files","view-ranking","view-case","view-chat","view-settings");
  document.body.classList.add("view-" + view);
const sidebar = document.querySelector(".sidebar");
  const main = document.querySelector(".main");
  const rightbar = document.querySelector(".rightbar");
  const startPanel = document.getElementById("startPanel");
  const rankingPanel = document.getElementById("rankingPanel");
  const casePanel = document.getElementById("casePanel");

  // Immer erst alles aus
  if(startPanel) startPanel.style.display = "none";
  if(rankingPanel) rankingPanel.style.display = "none";
  if(casePanel) casePanel.style.display = "none";
  sidebar.style.display = "none";
  main.style.display = "none";
  rightbar.style.display = "none";

  // Drawer states (mobile)
  ["navStart","navFiles","navRanking","navCase","navChat","navSettings"].forEach(id=>{
    const b = document.getElementById(id);
    if(b) b.classList.remove("active");
  });

  // Desktop tab states
  ["dnavStart","dnavFiles","dnavRanking","dnavCase","dnavChat","dnavSettings","dnavAdmin"].forEach(id=>{
    const b = document.getElementById(id);
    if(b) b.classList.remove("active");
  });

  if(view === "start"){
    if(startPanel) startPanel.style.display = "flex";
    document.getElementById("navStart")?.classList.add("active");
    document.getElementById("dnavStart")?.classList.add("active");
  } else if(view === "files"){
    main.style.display = "flex";
    document.getElementById("navFiles")?.classList.add("active");
    document.getElementById("dnavFiles")?.classList.add("active");
  } else if(view === "ranking"){
    if(rankingPanel) rankingPanel.style.display = "flex";
    document.getElementById("navRanking")?.classList.add("active");
    document.getElementById("dnavRanking")?.classList.add("active");
  } else if(view === "case"){
    if(casePanel) casePanel.style.display = "flex";
    document.getElementById("navCase")?.classList.add("active");
    document.getElementById("dnavCase")?.classList.add("active");
} else if(view === "chat"){
    rightbar.style.display = "flex";
    // ensure latest message is visible
    scrollChatBottom();
    document.getElementById("navChat")?.classList.add("active");
    document.getElementById("dnavChat")?.classList.add("active");
  } else if(view === "settings"){
    sidebar.style.display = "flex";
    document.getElementById("navSettings")?.classList.add("active");
    document.getElementById("dnavSettings")?.classList.add("active");
  }

  // Mobile Header nur auf Mobile anzeigen
  document.getElementById("mobileHeader")?.classList.toggle("hidden", !isMobile);

  // Desktop Nav nur auf Desktop anzeigen
  document.getElementById("desktopNavBar")?.classList.toggle("hidden", isMobile);
}


function closeDrawer(){
  document.getElementById("drawer")?.classList.add("hidden");
  document.getElementById("drawerOverlay")?.classList.add("hidden");
}

function openDrawer(){
  document.getElementById("drawer")?.classList.remove("hidden");
  document.getElementById("drawerOverlay")?.classList.remove("hidden");
}

function bindMobileMenu(){
  // Hamburger
  document.getElementById("btnHamburger")?.addEventListener("click", openDrawer);
  document.getElementById("btnCloseDrawer")?.addEventListener("click", closeDrawer);
  document.getElementById("drawerOverlay")?.addEventListener("click", closeDrawer);

  // Drawer navigation
  const go = (view)=>{ setMobileView(view); closeDrawer(); };
  document.getElementById("navStart")?.addEventListener("click", ()=>go("start"));
  document.getElementById("navFiles")?.addEventListener("click", ()=>go("files"));
  document.getElementById("navRanking")?.addEventListener("click", ()=>go("ranking"));
  document.getElementById("navCase")?.addEventListener("click", ()=>go("case"));
  document.getElementById("navChat")?.addEventListener("click", ()=>go("chat"));
document.getElementById("navAdmin")?.addEventListener("click", ()=>{ closeDrawer(); openAdmin(); });
  document.getElementById("navSettings")?.addEventListener("click", ()=>go("settings"));


  // Desktop navigation (PC) ‚Äì gleiche Views wie Mobile
  const goDesktop = (view)=>{ setMobileView(view); };
  document.getElementById("dnavStart")?.addEventListener("click", ()=>goDesktop("start"));
  document.getElementById("dnavFiles")?.addEventListener("click", ()=>goDesktop("files"));
  document.getElementById("dnavRanking")?.addEventListener("click", ()=>goDesktop("ranking"));
  document.getElementById("dnavCase")?.addEventListener("click", ()=>goDesktop("case"));
  document.getElementById("dnavChat")?.addEventListener("click", ()=>goDesktop("chat"));
document.getElementById("dnavSettings")?.addEventListener("click", ()=>goDesktop("settings"));
  document.getElementById("dnavAdmin")?.addEventListener("click", ()=>openAdmin());
  document.getElementById("dnavLogout")?.addEventListener("click", ()=>doLogout());

  // Start quick buttons
  document.getElementById("startGoFiles")?.addEventListener("click", ()=>go("files"));
  document.getElementById("startGoRanking")?.addEventListener("click", ()=>go("ranking"));
  document.getElementById("startGoCase")?.addEventListener("click", ()=>go("case"));
  document.getElementById("startGoChat")?.addEventListener("click", ()=>go("chat"));
  document.getElementById("startGoSettings")?.addEventListener("click", ()=>go("settings"));

  // Logout in drawer
  document.getElementById("drawerLogout")?.addEventListener("click", ()=>doLogout());

  // Default view
  const isMobile = window.matchMedia("(max-width: 980px)").matches;
  setMobileView(isMobile ? "start" : "files");

  // Update date line
  const updateDate = ()=>{
    const d = new Date();
    const dateStr = d.toLocaleDateString("de-CH", { weekday:"long", year:"numeric", month:"2-digit", day:"2-digit" });
    const timeStr = d.toLocaleTimeString("de-CH", { hour:"2-digit", minute:"2-digit" });
    { const el = document.getElementById("mhDateLine"); if(el) el.textContent = dateStr + " ‚Ä¢ " + timeStr; }
    { const el = document.getElementById("startDate"); if(el) el.textContent = dateStr + " ‚Ä¢ " + timeStr; }
    { const el = document.getElementById("startRoom"); if(el) el.textContent = (state.chatRoom || "global"); }
  };
  updateDate();
  setInterval(updateDate, 30_000);

  // Breakpoint handling (ignore keyboard resize)
  let _lastIsMobile = window.matchMedia("(max-width: 980px)").matches;
  window.addEventListener("resize", () => {
    const nowMobile = window.matchMedia("(max-width: 980px)").matches;
    if(nowMobile !== _lastIsMobile){
      _lastIsMobile = nowMobile;
      setMobileView(state.mobileView || (nowMobile ? "start" : "files"));
      closeDrawer();
    }
  });
}

// ---------- UI Bindings ----------
async function bindUI(){
  const click = (id, fn) => { const el = document.getElementById(id); if(el) el.addEventListener("click", fn); };
  const change = (id, fn) => { const el = document.getElementById(id); if(el) el.addEventListener("change", fn); };

  // Main actions (null-safe, so fehlende Buttons killen nicht den Login)
  click("btnNewCat", () => newCat().catch(()=>{}));
  click("btnPickFiles", () => document.getElementById("filePicker")?.click());
  change("filePicker", async (e) => {
    if(e.target.files?.length){
      try{ await handleFiles(e.target.files); } catch(_e){}
    }
    e.target.value = "";
  });
  click("btnCreateNote", () => createNote().catch(()=>{}));

  // Auth
  click("btnDoRegister", () => doRegister());
  click("btnDoLogin", () => doLogin());
  ["authUser","authPass"].forEach(id=>{
    const el = document.getElementById(id);
    if(!el) return;
    el.addEventListener("keydown", (e)=>{
      if(e.key === "Enter"){
        e.preventDefault();
        document.getElementById("btnDoLogin")?.click();
      }
    });
  });
  click("btnLogout", () => doLogout());
  click("btnLoginOpen", () => { const t=document.getElementById("authTitle"); if(t) t.textContent="Login"; document.getElementById("authUser")?.focus(); });
  click("btnRegisterOpen", () => { const t=document.getElementById("authTitle"); if(t) t.textContent="Registrierung"; document.getElementById("authUser")?.focus(); });

  // Chat
  click("btnSend", () => sendChat().catch(()=>{}));

  // Profil
  click("btnSaveProfile", () => saveMyProfile().catch((e)=>{ console.error(e); alert("Profil speichern fehlgeschlagen: " + (e?.message||e)); }));

  // Admin
  click("btnOpenAdmin", () => openAdmin());
  click("navAdmin", () => openAdmin());
  click("btnCloseAdmin", () => closeAdmin());
  click("btnSaveWhitelist", () => saveWhitelist().catch((e)=>{ console.error(e); alert("Whitelist speichern fehlgeschlagen: " + (e?.message||e)); }));
  click("btnSaveRole", () => saveRole().catch((e)=>{ console.error(e); alert("Rolle speichern fehlgeschlagen: " + (e?.message||e)); }));
  click("btnDeleteRole", () => deleteRole().catch((e)=>{ console.error(e); alert("Rolle l√∂schen fehlgeschlagen: " + (e?.message||e)); }));
  click("btnSetUserRole", () => setUserRole().catch((e)=>{ console.error(e); alert("User Rolle setzen fehlgeschlagen: " + (e?.message||e)); }));

  // F√§lle
  click("btnSaveCase", () => saveCase().catch((e)=>{ console.error(e); alert("Fall speichern fehlgeschlagen: " + (e?.message||e)); }));
  click("btnClearCase", () => clearCaseForm());

  // Dienste
  click("btnServiceStart", () => startService());
  click("btnServiceEnd", () => endService());
  click("btnServiceSave", () => saveService().catch((e)=>{ console.error(e); alert("Dienst speichern fehlgeschlagen: " + (e?.message||e)); }));
  click("btnServiceReset", () => clearServiceForm());

  // Dauer-Vorschau updaten, sobald Dienstende gesetzt ist und Zeiten ge√§ndert werden
  const _svcPreviewBump = ()=>{
    const endWrap = document.getElementById("serviceEndWrap");
    const saveBtn = document.getElementById("btnServiceSave");
    if(endWrap && !endWrap.classList.contains("hidden") && saveBtn && !saveBtn.disabled){
      updateServicePreviewLine();
    }
  };
  const _svcDateEl = document.getElementById("serviceDate");
  const _svcStartEl = document.getElementById("serviceStartTime");
  const _svcEndEl = document.getElementById("serviceEndTime");
  if(_svcDateEl) _svcDateEl.addEventListener("change", _svcPreviewBump);
  if(_svcStartEl) _svcStartEl.addEventListener("input", _svcPreviewBump);
  if(_svcEndEl) _svcEndEl.addEventListener("input", _svcPreviewBump);


  // Close overlays on ESC
  document.addEventListener("keydown", (e)=>{
    if(e.key === "Escape"){
      closeAdmin();
    }
  });
}


// ---------- Init ----------
(async function init(){
  applyBrand();
  bindUI();
  bindTypingUI();
  bindMobileMenu();
  setupDropzone();
  setupSearch();

  // Init default values for case form
  clearCaseForm();
  // Init Dienst-Erfassung
  clearServiceForm();

  applySessionUI();
  renderCats();
  renderItems();

  onAuthStateChanged(auth, async (user)=>{
    // cleanup old listeners
    if(state.unsubCats) state.unsubCats();
    if(state.unsubItems) state.unsubItems();
    if(state.unsubChat) state.unsubChat();
    if(state.unsubCases) state.unsubCases();

    if(user){
      state.session = {
        uid: user.uid,
        email: user.email || "",
        user: displayNameFromEmail(user.email || "")
      };

      // Ensure base config exists (security + roles)
      await ensureDefaultDocs().catch(()=>{});

      // Whitelist check (if not allowed -> sign out)
      const allowed = await isEmailAllowed(user.email || "").catch(()=>true);
      if(!allowed){
        alert("Diese E-Mail ist f√ºr die App nicht freigeschaltet (Whitelist).");
        await doLogout();
        return;
      }

      // Load profile + role, then UI
      await loadMyProfile(user.uid).catch(()=>{});
      watchMyProfile(user.uid);
      await loadMyRole(user.email || "", user.uid).catch(()=>{});
      // session name should reflect profile
      if(state.profile.displayName) state.session.user = state.profile.displayName;

      applySessionUI();
      applyPermsUI();
      

      // Presence
      watchPresence();
      startPresence();

      watchActiveDuty();

      await ensureDefaultCats(user.uid);
      watchCats();
      watchItems();
      watchChatEnhanced();
      watchTyping();
      watchCases();
      watchServices();
      clearCaseForm();
      clearServiceForm();
      renderRanking();
    } else {
      // Cleanup listeners/timers
      stopPresence();
      if(state.unsubPresence) state.unsubPresence();
      state.unsubPresence = null;
      state.onlineUsers = [];
      renderPresenceBar();

      
      
      state.rankings = [];
      renderRanking();

      state.session = null;
      state.cats = [];
      state.items = [];
      applySessionUI();
      renderCats();
      renderItems();
      // Cleanup cases
      if(state.unsubCases) state.unsubCases();
      state.unsubCases = null;
      state.cases = [];
      state.rankings = [];
      renderMyCases();
      renderRanking();
      // Cleanup services
      if(state.unsubServices) state.unsubServices();
      state.unsubServices = null;
      state.services = [];
      renderServices();
      clearServiceForm();
      // clear chat UI
      $("chatLog").innerHTML = "";
    }
  });
})();

/*
==========================================
Beispiel Firestore Rules (sehr wichtig!)
==========================================
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /users/{userId}/{document=**} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    // optional user profile
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
  }
}

==========================================
Beispiel Storage Rules
==========================================
rules_version = '2';
service firebase.storage {
  match /b/{bucket}/o {
    match /users/{userId}/{allPaths=**} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
  }
}
*/

// --- Mobile anti-jump (Android/iOS WebView/Safari):
(function(){
  let lastY = 0;
  const isInput = (el)=> el && (el.tagName==="INPUT"||el.tagName==="TEXTAREA"||el.isContentEditable);
  document.addEventListener("touchstart", ()=>{ lastY = window.scrollY; }, {passive:true});
  document.addEventListener("focusin", (e)=>{
    if(!isInput(e.target)) return;
    lastY = window.scrollY;
    // Some browsers jump to top on focus; restore shortly after.
    setTimeout(()=>{ 
      if(window.scrollY === 0 && lastY > 0) window.scrollTo(0, lastY);
    }, 50);
    setTimeout(()=>{ 
      if(window.scrollY === 0 && lastY > 0) window.scrollTo(0, lastY);
    }, 250);
  });
  window.addEventListener("resize", ()=>{
    // keyboard open/close can trigger a scroll reset
    setTimeout(()=>{ 
      if(window.scrollY === 0 && lastY > 0) window.scrollTo(0, lastY);
    }, 60);
  });
})();


// ===== Chat Enhancements v31 =====

// ===== Chat Unread Badge (Tabs) =====
window.chatUnreadCount = window.chatUnreadCount || 0;

function __ensureChatBadges(){
  const targets = [
    { btnId: "navChat",  badgeId: "badgeNavChat"  },
    { btnId: "dnavChat", badgeId: "badgeDnavChat" },
    { btnId: "mbChat",   badgeId: "badgeMbChat"   },
  ];
  targets.forEach(t=>{
    const btn = document.getElementById(t.btnId);
    if(!btn) return;
    btn.classList.add("hasBadge");
    let b = document.getElementById(t.badgeId);
    if(!b){
      b = document.createElement("span");
      b.id = t.badgeId;
      b.className = "tabBadge hidden";
      btn.appendChild(b);
    }
  });
}

function setChatUnreadBadge(count){
  const n = Math.max(0, Number(count) || 0);
  window.chatUnreadCount = n;
  ["badgeNavChat","badgeDnavChat","badgeMbChat"].forEach(id=>{
    const el = document.getElementById(id);
    if(!el) return;
    if(n > 0){
      el.textContent = (n > 99) ? "99+" : String(n);
      el.classList.remove("hidden");
    } else {
      el.textContent = "";
      el.classList.add("hidden");
    }
  });
}

document.addEventListener("DOMContentLoaded", ()=>{
  __ensureChatBadges();
  setChatUnreadBadge(window.chatUnreadCount || 0);
});

var CHAT_LIMIT = window.CHAT_LIMIT || 500;
window.CHAT_LIMIT = CHAT_LIMIT;
window.shouldAutoScroll = window.shouldAutoScroll || function(container, threshold = 80){
  return (container.scrollHeight - container.scrollTop - container.clientHeight) < threshold;
}
var newMsgCount = window.newMsgCount || 0;
window.newMsgCount = newMsgCount;
var newMsgBtn = window.newMsgBtn || document.getElementById('newMsgBtn') || document.createElement('button');
window.newMsgBtn = newMsgBtn;
if(!newMsgBtn.id) newMsgBtn.id = 'newMsgBtn';
newMsgBtn.textContent = '‚¨á Neue Nachrichten';
newMsgBtn.style.position = 'fixed';
newMsgBtn.style.right = '16px';
newMsgBtn.style.bottom = '96px';
newMsgBtn.style.display = 'none';
newMsgBtn.className = 'btn primary';
if(!document.getElementById('newMsgBtn')) document.body.appendChild(newMsgBtn);
newMsgBtn.onclick = ()=>{
  const log = document.getElementById('chatLog');
  if(log){ log.scrollTop = log.scrollHeight; }
  newMsgCount = 0;
  newMsgBtn.style.display = 'none';
};
const _oldWatchChat = watchChat;
watchChat = function(){
  if(state.unsubChat) state.unsubChat();
  const userId = requireLogin();
  const roomId = state.chatRoom || 'global';
  const qChat = query(chatCol(roomId), orderBy('at','asc'));
  state.unsubChat = onSnapshot(qChat, (snap)=>{
    const log = document.getElementById('chatLog');
    if(!log) return;

    // --- Unread badge for Chat tabs ---
    const __curView = (state && state.mobileView) ? state.mobileView : (document.body.classList.contains("view-chat") ? "chat" : "");
    if(typeof state.__chatSnapInit === "undefined") state.__chatSnapInit = false;

    if(!state.__chatSnapInit){
      // first snapshot should not create unread counts
      state.__chatSnapInit = true;
      if(__curView === "chat") setChatUnreadBadge(0);
    } else {
      let __addedFromOthers = 0;
      try{
        snap.docChanges().forEach(ch=>{
          if(ch.type !== "added") return;
          const m = ch.doc.data() || {};
          if(m.uid && m.uid === userId) return; // ignore my own messages
          __addedFromOthers++;
        });
      }catch(_e){}
      if(__curView !== "chat" && __addedFromOthers > 0){
        setChatUnreadBadge((window.chatUnreadCount || 0) + __addedFromOthers);
      } else if(__curView === "chat" && (window.chatUnreadCount || 0) > 0){
        setChatUnreadBadge(0);
      }
    }
    const auto = shouldAutoScroll(log);
    log.innerHTML = '';
    let lastDate = '';
    snap.docs.slice(-CHAT_LIMIT).forEach(d=>{
      const m = d.data();
      const at = m.at?.toMillis ? m.at.toMillis() : Date.now();
      const dstr = new Date(at).toLocaleDateString('de-CH');
      if(dstr !== lastDate){
        const sep = document.createElement('div');
        sep.style.textAlign='center';
        sep.style.opacity='0.6';
        sep.style.margin='10px 0';
        sep.textContent = 'üìÖ ' + dstr;
        log.appendChild(sep);
        lastDate = dstr;
      }
      const b = document.createElement('div');
      b.className = 'bubble ' + ((m.uid && m.uid===userId)?'me':'');
      if(m.type==='system'){
        b.style.opacity='0.7';
        b.innerHTML = '<em>'+escapeHtml(m.text)+'</em>';
      }else{
        let reply = '';
        if(m.replyToText){
          reply = '<div style="font-size:11px;opacity:.7;border-left:2px solid #7c5cff;padding-left:6px;margin-bottom:4px">'+escapeHtml(m.replyToText)+'</div>';
        }
        b.innerHTML = reply + '<div>'+escapeHtml(m.text)+'</div><div class="t">'+escapeHtml(m.user||'User')+' ‚Ä¢ '+new Date(at).toLocaleTimeString('de-CH',{hour:'2-digit',minute:'2-digit'})+'</div>';
      }
      log.appendChild(b);
    });
    if(auto){
      requestAnimationFrame(()=>{ log.scrollTop = log.scrollHeight; });
    }else{
      newMsgCount++;
      newMsgBtn.style.display = 'block';
      newMsgBtn.textContent = '‚¨á Neue Nachrichten ('+newMsgCount+')';
    }
  });
};



// ===== Chat Enhancements v39 (No Reply/Reactions, Clear fix, Roles, Cleanup) =====
var CHAT_LIMIT = window.CHAT_LIMIT || 500;
window.CHAT_LIMIT = CHAT_LIMIT;

// helper (keep existing if already defined)
var shouldAutoScroll = window.shouldAutoScroll || function(container, threshold = 80){
  return (container.scrollHeight - container.scrollTop - container.clientHeight) < threshold;
};
window.shouldAutoScroll = shouldAutoScroll;

// New messages indicator button
var newMsgCount = window.newMsgCount || 0;
window.newMsgCount = newMsgCount;
var newMsgBtn = window.newMsgBtn || document.getElementById("newMsgBtn");
window.newMsgBtn = newMsgBtn;
if(!newMsgBtn){
newMsgBtn = window.newMsgBtn || document.createElement("button");
  newMsgBtn.id = "newMsgBtn";
  newMsgBtn.textContent = "‚¨á Neue Nachrichten";
  newMsgBtn.style.position = "fixed";
  newMsgBtn.style.right = "16px";
  newMsgBtn.style.bottom = "96px";
  newMsgBtn.style.display = "none";
  newMsgBtn.className = "btn primary";
  if(!document.getElementById('newMsgBtn')) document.body.appendChild(newMsgBtn);
}
newMsgBtn.onclick = ()=>{
  const log = document.getElementById("chatLog");
  if(log) log.scrollTop = log.scrollHeight;
  newMsgCount = 0;
  newMsgBtn.style.display = "none";
};

// Sound + Notification
let _chatBootstrapped = false;
let _lastChatDocId = null;
let _lastChatAt = 0;

function playBeep(){
  try{
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = "sine";
    o.frequency.value = 740;
    g.gain.value = 0.03;
    o.connect(g); g.connect(ctx.destination);
    o.start();
    setTimeout(()=>{ o.stop(); ctx.close().catch(()=>{}); }, 110);
  }catch(_e){}
}
async function maybeNotifyNewMessage(m){
  if(!m) return;
  if(m.uid && m.uid === state.session?.uid) return;
  if(document.visibilityState !== "hidden") return;
  if(!("Notification" in window)) return;

  if(Notification.permission === "default"){
    try{ await Notification.requestPermission(); }catch(_e){}
  }
  if(Notification.permission === "granted"){
    try{
      new Notification("Projekt TAS ‚Äì Chat", { body: `${m.user || "User"}: ${m.text || ""}`.slice(0, 160) });
    }catch(_e){}
  }
}

// Moderation (mute + clear)
const CHAT_MOD_DOC = doc(db, "appConfig", "global", "chatModeration", "state"); // { muted: [strings] }
let mutedList = [];
async function loadModeration(){
  const s = await getDoc(CHAT_MOD_DOC).catch(()=>null);
  mutedList = (s?.data()?.muted || []).map(x=>String(x||"").trim()).filter(Boolean);
}
function isMuted(){
  const uid = (state.session?.uid || "").toLowerCase();
  const email = (state.session?.email || "").toLowerCase();
  const set = new Set((mutedList||[]).map(x=>String(x||"").toLowerCase()));
  return set.has(uid) || set.has(email);
}
async function saveMutedFromUI(){
  if(!perms().canAdmin) return alert("Keine Admin-Rechte.");
  const box = document.getElementById("mutedBox");
  const lines = (box?.value || "").split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  const unique = Array.from(new Set(lines.map(s=>s.toLowerCase())));
  await setDoc(CHAT_MOD_DOC, { muted: unique, updatedAt: serverTimestamp() }, { merge:true });
  mutedList = unique;
  alert("Muted gespeichert.");
}
async function clearChatLast500(){
  if(!perms().canAdmin) return alert("Keine Admin-Rechte.");
  if(!confirm("Wirklich die letzten 500 Chat-Nachrichten l√∂schen?")) return;
  const roomId = state.chatRoom || "global";
  const snap = await getDocs(query(chatCol(roomId), orderBy("at","desc"), limit(500))).catch(()=>null);
  const docs = (snap?.docs || []);
  for(const d of docs){
    await deleteDoc(d.ref).catch((e)=>console.error("delete failed", e));
  }
  alert("Chat geleert (letzte 500).");
}
async function clearSystemLast500(){
  if(!perms().canAdmin) return alert("Keine Admin-Rechte.");
  if(!confirm("Wirklich Systemmeldungen (letzte 500) l√∂schen?")) return;
  const roomId = state.chatRoom || "global";
  const snap = await getDocs(query(chatCol(roomId), orderBy("at","desc"), limit(500))).catch(()=>null);
  const docs = (snap?.docs || []).filter(d => (d.data()?.type === "system"));
  for(const d of docs){
    await deleteDoc(d.ref).catch(()=>{});
  }
  alert("Systemmeldungen gel√∂scht.");
}

// Chat roles
const CHAT_ROLES_COL = collection(db, "appConfig", "global", "chatRoles"); // doc id = email (lowercase) -> {email, role}
chatRoles = window.chatRoles || chatRoles || {}; window.chatRoles = chatRoles;
let unsubChatRoles = null;

function roleIcon(role){
  if(role === "admin") return "üõ°Ô∏è";
  if(role === "mod") return "üß©";
  return "";
}
function getRoleForMessage(m){
  const email = (m.email || "").toLowerCase();
  return chatRoles[email] || "user";
}
function watchChatRoles(){
  if(unsubChatRoles) unsubChatRoles();
  unsubChatRoles = onSnapshot(CHAT_ROLES_COL, (snap)=>{
    const map = {};
    snap.forEach(d=>{
      const data = d.data() || {};
      const email = String(data.email || d.id || "").toLowerCase();
      if(email) map[email] = String(data.role || "user");
    });
    chatRoles = map;
    // Update textarea if admin menu open
    const box = document.getElementById("chatRolesBox");
    if(box){
      const lines = Object.entries(chatRoles).sort((a,b)=>a[0].localeCompare(b[0])).map(([e,r])=>`${e} = ${r}`);
      box.value = lines.join("\n");
    }
  });
}
async function setChatRole(){
  if(!perms().canAdmin) return alert("Keine Admin-Rechte.");
  const email = (document.getElementById("chatRoleEmail")?.value || "").trim().toLowerCase();
  const role = (document.getElementById("chatRoleSelect")?.value || "user").trim();
  if(!email || !email.includes("@")) return alert("Bitte g√ºltige E-Mail eingeben.");
  await setDoc(doc(db,"appConfig","global","chatRoles", email), { email, role, updatedAt: serverTimestamp() }, { merge:true });
  alert("Chat-Rolle gespeichert.");
}
async function deleteChatRole(){
  if(!perms().canAdmin) return alert("Keine Admin-Rechte.");
  const email = (document.getElementById("chatRoleEmail")?.value || "").trim().toLowerCase();
  if(!email || !email.includes("@")) return alert("Bitte g√ºltige E-Mail eingeben.");
  await deleteDoc(doc(db,"appConfig","global","chatRoles", email));
  alert("Chat-Rolle gel√∂scht.");
}

// Bind admin moderation buttons (safe even if not admin)
(function(){
  document.getElementById("btnSaveMuted")?.addEventListener("click", ()=> saveMutedFromUI().catch(e=>alert(e?.message||e)));
  document.getElementById("btnClearChat")?.addEventListener("click", ()=> clearChatLast500().catch(e=>alert(e?.message||e)));
  document.getElementById("btnClearSystem")?.addEventListener("click", ()=> clearSystemLast500().catch(e=>alert(e?.message||e)));
  document.getElementById("btnSetChatRole")?.addEventListener("click", ()=> setChatRole().catch(e=>alert(e?.message||e)));
  document.getElementById("btnDeleteChatRole")?.addEventListener("click", ()=> deleteChatRole().catch(e=>alert(e?.message||e)));
})();

// Patch sendChat: add email field + mute check + trigger push via Netlify Function
sendChat = async function(){
  await loadModeration().catch(()=>{});
  if(isMuted()){
    alert("Du bist aktuell gemutet und kannst keine Nachrichten senden.");
    return;
  }

  const inp = document.getElementById("chatText");
  const text = (inp?.value || "").trim();
  if(!text) return;

  const userId = requireLogin();
  const roomId = state.chatRoom || "global";
  const user = state.session?.user || "User";
  const email = state.session?.email || "";

  // 1) write message to Firestore
  await addDoc(chatCol(roomId), { text, user, uid: userId, email, at: serverTimestamp() });

  // 2) trigger push via Netlify Function (best-effort, non-blocking)
  try{
    const cur = auth?.currentUser || null;
    const idToken = cur ? await cur.getIdToken() : null;

    fetch("/.netlify/functions/push_chat", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        ...(idToken ? { "Authorization": "Bearer " + idToken } : {})
      },
      body: JSON.stringify({ roomId, text, user, uid: userId, email })
    }).catch(()=>{});
  }catch(_e){}

  // UI cleanup
  if(inp) inp.value = "";
  setMyTyping(false).catch(()=>{});
  try{ scrollChatBottom(true); }catch(_e){ const log=document.getElementById("chatLog"); if(log) log.scrollTop = log.scrollHeight; }
};


// Enhanced watcher (forced by v37)

async function watchChatEnhanced(){
  if(state.unsubChat) state.unsubChat();
  const userId = requireLogin();
  const roomId = state.chatRoom || "global";

  // Ensure chat roles watcher running
  try{ watchChatRoles(); }catch(_e){}

  const qChat = query(chatCol(roomId), orderBy("at","asc"));
  state.unsubChat = onSnapshot(qChat, async (snap)=>{
    const log = document.getElementById("chatLog");
    if(!log) return;


    // --- Unread badge for Chat tabs (works even when not on Chat view) ---
    try{
      const __curView = (state && state.mobileView) ? state.mobileView : (document.body.classList.contains("view-chat") ? "chat" : "");
      if(typeof state.__chatSnapInitEnhanced === "undefined") state.__chatSnapInitEnhanced = false;

      if(!state.__chatSnapInitEnhanced){
        // first snapshot should not count as unread
        state.__chatSnapInitEnhanced = true;
        if(__curView === "chat") setChatUnreadBadge(0);
      } else {
        let __addedFromOthers = 0;
        try{
          snap.docChanges().forEach(ch=>{
            if(ch.type !== "added") return;
            const m = ch.doc.data() || {};
            if(m.uid && m.uid === userId) return; // ignore my own messages
            __addedFromOthers++;
          });
        }catch(_e){}
        if(__curView !== "chat" && __addedFromOthers > 0){
          setChatUnreadBadge((window.chatUnreadCount || 0) + __addedFromOthers);
        } else if(__curView === "chat" && (window.chatUnreadCount || 0) > 0){
          setChatUnreadBadge(0);
        }
      }
    }catch(_e){}
    const auto = shouldAutoScroll(log);
    const docs = snap.docs.slice(-CHAT_LIMIT);

    // identify last for notifications/sound
    const last = docs[docs.length - 1];
    const lastData = last?.data?.() || null;
    const lastAt = lastData?.at?.toMillis ? lastData.at.toMillis() : 0;
    const lastId = last?.id || null;

    log.innerHTML = "";
    let lastDate = "";

    // helper: can current user delete message?
    const canDeleteMsg = (m)=> (perms().canAdmin || (m.uid && m.uid === userId));

    // helper: swipe-to-delete (mobile)
    const bindSwipeToDelete = (el, docRef, m)=>{
      if(!el) return;
      if(!canDeleteMsg(m)) return;

      let x0 = 0, y0 = 0, dx = 0, active = false, locked = false;
      const threshold = 78;     // px to trigger delete
      const lockRatio = 1.2;    // horizontal dominance

      const onStart = (e)=>{
        const t = e.touches?.[0];
        if(!t) return;
        x0 = t.clientX; y0 = t.clientY;
        dx = 0; active = true; locked = false;
        el.style.transition = "none";
      };

      const onMove = (e)=>{
        if(!active) return;
        const t = e.touches?.[0];
        if(!t) return;

        const mx = t.clientX - x0;
        const my = t.clientY - y0;

        // decide direction once
        if(!locked){
          if(Math.abs(mx) < 6 && Math.abs(my) < 6) return;
          locked = true;
          // only handle left swipe, and only if horizontal dominates
          if(!(mx < 0 && Math.abs(mx) > Math.abs(my) * lockRatio)){
            active = false;
            el.style.transition = "";
            el.style.transform = "";
            el.parentElement?.classList?.remove("showDel");
            return;
          }
        }

        // prevent scroll while swiping
        e.preventDefault();

        dx = Math.max(mx, -140); // cap
        el.style.transform = `translateX(${dx}px)`;

        const wrap = el.parentElement;
        if(wrap){
          wrap.classList.toggle("showDel", dx < -24);
        }
      };

      const onEnd = async ()=>{
        if(!active) return;
        active = false;
        el.style.transition = "transform .12s ease";
        el.style.transform = "";
        el.parentElement?.classList?.remove("showDel");

        if(dx <= -threshold){
          if(!confirm("Nachricht l√∂schen?")) return;
          await deleteDoc(docRef).catch(()=>{});
        }
      };

      // use non-passive move to allow preventDefault
      el.addEventListener("touchstart", onStart, {passive:true});
      el.addEventListener("touchmove", onMove, {passive:false});
      el.addEventListener("touchend", onEnd, {passive:true});
      el.addEventListener("touchcancel", onEnd, {passive:true});
    };

    for(const d of docs){
      const m = d.data() || {};
      const at = m.at?.toMillis ? m.at.toMillis() : Date.now();
      const dateKey = new Date(at).toLocaleDateString("de-CH");

      if(dateKey !== lastDate){
        const sep = document.createElement("div");
        sep.className = "dateSep";
        sep.textContent = dateKey;
        log.appendChild(sep);
        lastDate = dateKey;
      }

      // system messages
      if(m.type === "system"){
        const sys = document.createElement("div");
        sys.className = "bubble";
        sys.style.opacity = "0.75";
        sys.innerHTML = `<em>${escapeHtml(m.text || "")}</em>`;
        log.appendChild(sys);
        continue;
      }

      // wrapper enables swipe delete hint background
      const wrap = document.createElement("div");
      const isMe = (m.uid && m.uid === userId);
      wrap.className = "chatSwipeBg" + (isMe ? " me" : "");

      const bubble = document.createElement("div");
      bubble.className = "bubble " + ((m.uid && m.uid === userId) ? "me" : "");

      // Header line (role icon + name + time) like Signal
      const role = getRoleForMessage(m);
      const icon = roleIcon(role);
      const timeStr = new Date(at).toLocaleTimeString("de-CH",{hour:"2-digit",minute:"2-digit"});

      // Show name only for other people's messages
      const nameLine = `${icon ? icon + " " : ""}${escapeHtml(m.user || "User")}`;
      const metaLine = `${timeStr}`;

      bubble.innerHTML = `
        ${((m.uid && m.uid !== userId) ? `<div class="u">${nameLine}</div>` : "")}
        <div>${escapeHtml(m.text || "")}</div>
        <div class="t"><span>${metaLine}</span></div>
      `;

      // swipe-to-delete binding
      bindSwipeToDelete(bubble, d.ref, m);

      wrap.appendChild(bubble);
      log.appendChild(wrap);
    }

    if(auto || (lastData && lastData.uid && lastData.uid === userId)){
      requestAnimationFrame(()=>{ log.scrollTop = log.scrollHeight; });
      newMsgCount = 0;
      if(newMsgBtn) newMsgBtn.style.display = "none";
    } else {
      if(_chatBootstrapped && lastId && lastId !== _lastChatDocId){
        newMsgCount++;
        if(newMsgBtn){
          newMsgBtn.style.display = "block";
          newMsgBtn.textContent = `‚¨á Neue Nachrichten (${newMsgCount})`;
        }
      }
    }

    // Notifications + sound (keep behavior)
    if(!_chatBootstrapped){
      _chatBootstrapped = true;
      _lastChatDocId = lastId;
      _lastChatAt = lastAt;
      return;
    }
    if(lastId && lastId !== _lastChatDocId && lastAt >= _lastChatAt){
      _lastChatDocId = lastId;
      _lastChatAt = lastAt;
      playBeep();
      await maybeNotifyNewMessage(lastData).catch(()=>{});
    }
  });
}


// Fix: JS uses true not True


watchChat = watchChatEnhanced;

// Hook: when Admin overlay opens, preload mute list into textarea
const _origLoadAdminUI = loadAdminUI;
loadAdminUI = async function(){
  await _origLoadAdminUI();
  if(!perms().canAdmin) return;
  await loadModeration().catch(()=>{});
  const box = document.getElementById("mutedBox");
  if(box) box.value = (mutedList || []).join("\n");
  // v39: preload moderation + chat roles
  try{
    await loadModeration().catch(()=>{});
    const mb = document.getElementById("mutedBox");
    if(mb) mb.value = (mutedList || []).join("\n");
  }catch(_e){}
  try{
    const box = document.getElementById("chatRolesBox");
    if(box){
      const lines = Object.entries(chatRoles||{}).sort((a,b)=>a[0].localeCompare(b[0])).map(([e,r])=>`${e} = ${r}`);
      box.value = lines.join("\n");
    }
  }catch(_e){}

};


// Request Notification permission from Settings button (optional)
document.getElementById("navSettings")?.addEventListener("click", async ()=>{
  if("Notification" in window && Notification.permission === "default"){
    try{ await Notification.requestPermission(); }catch(_e){}
  }
});

// v32: ensure latest chat renderer is active
try{ setTimeout(()=>{ if(state?.session?.uid){ watchChatEnhanced(); } }, 0); }catch(_e){}


// v36: ensure enhanced chat renderer binds after login (even if auth completes later)
try{
  let __rebound = false;
  const __t = setInterval(()=>{
    if(__rebound) return;
    if(state?.session?.uid){
      __rebound = true;
      try{ watchChatEnhanced(); }catch(_e){}
      clearInterval(__t);
    }
  }, 250);
  setTimeout(()=>{ if(!__rebound){ clearInterval(__t); } }, 15000);
}catch(_e){}


// ===== Mobile Setup bindings v48 =====
function setMobileTabActive(view){
  const map = {
    start: "mbStart",
    files: "mbDocs",
    ranking: "mbRank",
    case: "mbCase",
    chat: "mbChat",
    settings: "mbSettings",
    admin: null
  };
  document.querySelectorAll("#mobileBottomNav .mbtn").forEach(b=>b.classList.remove("active"));
  const id = map[view];
  if(id){
    const el = document.getElementById(id);
    if(el) el.classList.add("active");
  }
}

// Hook into setMobileView to also update bottom nav active state
const _setMobileView_v48 = setMobileView;
setMobileView = function(view){
  if(view === "docs") view = "files"; // normalize legacy name
  _setMobileView_v48(view);
  setMobileTabActive(view);
  if(view === "chat"){ try{ setChatUnreadBadge(0); }catch(_e){} }

};

// Bind bottom nav clicks (no out-of-scope go())
(function(){
  const bind = (id, view)=>{
    const el = document.getElementById(id);
    if(!el) return;
    el.addEventListener("click", ()=> setMobileView(view));
  };
  bind("mbStart","start");
  bind("mbDocs","files");
  bind("mbRank","ranking");
  bind("mbCase","case");
  bind("mbChat","chat");
  bind("mbSettings","settings");
})();

// ===== Notifications v49 =====
async function requestNotifPermission(){
  if(!("Notification" in window)) return "unsupported";
  if(Notification.permission === "granted") return "granted";
  try{
    const p = await Notification.requestPermission();
    return p;
  }catch(e){
    console.warn("Notification permission failed", e);
    return "denied";
  }
}
function canShowNotif(){
  return ("Notification" in window) && Notification.permission === "granted";
}
function showChatNotif(title, body){
  if(!canShowNotif()) return;
  try{
    const n = new Notification(title, { body: (body||"").slice(0, 180) });
    setTimeout(()=>{ try{ n.close(); }catch(_){} }, 6000);
  }catch(e){
    console.warn("Notification failed", e);
  }
}
// Optional: small in-app toast (works on mobile too)
function toast(msg){
  let t = document.getElementById("toast");
  if(!t){
    t = document.createElement("div");
    t.id = "toast";
    t.style.position="fixed";
    t.style.left="50%";
    t.style.bottom="92px";
    t.style.transform="translateX(-50%)";
    t.style.padding="10px 12px";
    t.style.borderRadius="14px";
    t.style.border="1px solid var(--border)";
    t.style.background="rgba(0,0,0,.65)";
    t.style.color="var(--text)";
    t.style.zIndex="60";
    t.style.maxWidth="92vw";
    t.style.textAlign="center";
    t.style.fontSize="13px";
    t.style.display="none";
    document.body.appendChild(t);
  }
  t.textContent = msg;
  t.style.display="block";
  clearTimeout(window.__toastT);
  window.__toastT = setTimeout(()=>{ t.style.display="none"; }, 2600);
}
// Bind settings buttons
(function(){
  const b = document.getElementById("btnEnableNotif");
  const t = document.getElementById("btnTestNotif");
  const hint = document.getElementById("notifHint");
  if(b){
    b.addEventListener("click", async ()=>{
      const p = await requestNotifPermission();
      if(hint) hint.textContent = (p==="granted")
        ? "‚úÖ Benachrichtigungen sind aktiviert."
        : (p==="denied" ? "‚ùå Benachrichtigungen abgelehnt (Browser-Einstellungen pr√ºfen)." : "‚ö†Ô∏è Benachrichtigungen nicht verf√ºgbar.");
      if(p==="granted") showChatNotif("Projekt TAS", "Benachrichtigungen sind aktiv ‚úÖ");
    });
  }
  if(t){
    t.addEventListener("click", async ()=>{
      const p = await requestNotifPermission();
      if(p==="granted") showChatNotif("Projekt TAS ‚Äì Test", "Wenn du das siehst, klappt es ‚úÖ");
      else toast("Benachrichtigungen nicht aktiv (erst erlauben).");
    });
  }
})();

// Patch maybeNotifyNewMessage to trigger more reliably:
// - when tab hidden OR window not focused
if(typeof maybeNotifyNewMessage === "function"){
  const _maybe = maybeNotifyNewMessage;
  maybeNotifyNewMessage = async function(m){
    // keep old behavior if exists
    try{ await _maybe(m); }catch(_e){}
    if(!m) return;
    if(m.uid && m.uid === state.session?.uid) return;
    const notFocused = (document.visibilityState !== "visible") || (typeof document.hasFocus==="function" && !document.hasFocus());
    if(!notFocused) return;
    // ensure permission (cannot auto-request without gesture)
    if(!canShowNotif()) return;
    showChatNotif("Projekt TAS ‚Äì Chat", `${m.user || "User"}: ${m.text || ""}`);
  };
}


// ===== Chat UX: keep input visible on focus (mobile) =====
(function(){
  const inp = document.getElementById("chatText");
  if(!inp) return;
  inp.addEventListener("focus", ()=>{
    try{ scrollChatBottom(true); }catch(_e){}
    setTimeout(()=>{ try{ scrollChatBottom(true); }catch(_e){} }, 120);
  });
})();


// ===== Mobile Keyboard Offset (VisualViewport) =====
(function(){
  function setKb(){
    try{
      const vv = window.visualViewport;
      let kb = 0;
      if(vv){
        kb = Math.max(0, (window.innerHeight - vv.height - vv.offsetTop));
      }
      document.documentElement.style.setProperty("--kb", kb + "px");
    }catch(_e){}
  }
  setKb();
  if(window.visualViewport){
    window.visualViewport.addEventListener("resize", setKb);
    window.visualViewport.addEventListener("scroll", setKb);
  }
  window.addEventListener("resize", setKb);
  window.addEventListener("orientationchange", ()=> setTimeout(setKb, 150));
})();


// ===== Ensure chat stays pinned to bottom when entering chat view =====
(function(){
  const _orig = window.setMobileView;
  if(typeof _orig !== "function") return;
  window.setMobileView = function(view){
    _orig(view);
    if(view === "chat"){
      setTimeout(()=>{ try{ scrollChatBottom(true); }catch(_e){} }, 50);
      setTimeout(()=>{ try{ scrollChatBottom(true); }catch(_e){} }, 180);
    }
  };
})();


// ===== Scoped scroll: lock page only on chat tab =====
(function(){
  const orig = window.setMobileView;
  if(typeof orig !== "function") return;
  window.setMobileView = function(view){
    try{
      document.body.classList.toggle("view-chat", view === "chat");
    }catch(_e){}
    return orig(view);
  };
  // initial state (in case chat is default)
  try{
    const chatShown = !!document.querySelector(".rightbar") && (document.querySelector(".rightbar").style.display || "").includes("flex");
    if(chatShown) document.body.classList.add("view-chat");
  }catch(_e){}
})();


// ===== Prevent page scroll in chat view (allow only chatLog) =====
(function(){
  const vp = document.querySelector(".viewport");
  const isInsideChatLog = (t)=> !!(t && (t.closest && t.closest("#chatLog")));
  function shouldBlock(e){
    if(!document.body.classList.contains("view-chat")) return false;
    return !isInsideChatLog(e.target);
  }
  function onWheel(e){
    if(shouldBlock(e)) e.preventDefault();
  }
  function onTouchMove(e){
    if(shouldBlock(e)) e.preventDefault();
  }
  if(vp){
    vp.addEventListener("wheel", onWheel, {passive:false});
    vp.addEventListener("touchmove", onTouchMove, {passive:false});
  }
})();


// ===== Measure chat input height and reserve space in chatLog =====
(function(){
  function update(){
    if(!document.body.classList.contains("view-chat")) return;
    const inp = document.querySelector(".rightbar .chatInput");
    if(!inp) return;
    const h = Math.max(56, Math.round(inp.getBoundingClientRect().height));
    document.documentElement.style.setProperty("--chatInputH", h + "px");
  }
  // run on load and on resize
  window.addEventListener("resize", ()=> setTimeout(update, 50));
  window.addEventListener("orientationchange", ()=> setTimeout(update, 120));

  // observe size changes (button text wrapping etc.)
  try{
    const ro = new ResizeObserver(()=> update());
    const hook = ()=>{
      const inp = document.querySelector(".rightbar .chatInput");
      if(inp) ro.observe(inp);
      update();
    };
    hook();
    // also re-hook when switching tabs
    const orig = window.setMobileView;
    if(typeof orig === "function"){
      window.setMobileView = function(view){
        const r = orig(view);
        setTimeout(()=>{ update(); }, 60);
        setTimeout(()=>{ update(); }, 180);
        return r;
      };
    }
  }catch(_e){
    setInterval(update, 800);
  }

  // initial
  setTimeout(update, 100);
})();


// ===== Mobile view classes (for headbar + side columns control) =====
(function(){
  const orig = window.setMobileView;
  if(typeof orig !== "function") return;

  function apply(view){
    const views = ["start","files","rank","case","chat","settings"];
    for(const v of views) document.body.classList.toggle("view-"+v, view === v);
  }

  window.setMobileView = function(view){
    apply(view);
    return orig(view);
  };

  // initial: guess based on which panel is visible
  try{
    const map = [
      ["start","startPanel"],
      ["files","filesPanel"],
      ["rank","rankingPanel"],
      ["case","casePanel"],
      ["chat","chatPanel"],
      ["settings","settingsPanel"]
    ];
    let current = "start";
    for(const [v,id] of map){
      const el = document.getElementById(id);
      if(el && (getComputedStyle(el).display !== "none")){
        current = v; break;
      }
    }
    apply(current);
  }catch(_e){}
})();


// ===== Google Drive integration (open folder) =====
const DRIVE_FOLDER_URL = "https://drive.google.com/drive/folders/1tsABJ9d963_-8WTqCkvmsEYHKanj3Tx-?usp=sharing";

(function(){
  const b = document.getElementById("btnOpenDrive");
  if(!b) return;
  b.addEventListener("click", ()=>{
    if(DRIVE_FOLDER_URL.includes("PASTE_YOUR_FOLDER_ID_HERE")){
      alert("Bitte DRIVE_FOLDER_URL im Code setzen (Google Drive Ordner-Link).");
      return;
    }
    window.open(DRIVE_FOLDER_URL, "_blank", "noopener");
  });
})();
/* Infos: SecuriReport */
(()=>{
  const SECURIREPORT_URL = "https://securireport3.securitas.ch/securireport/desktop-app/#login";

  // Some browsers / PWA contexts block location.assign for external URLs.
  // Use window.open (new tab) and fall back to a direct navigation.
  function openExternal(url){
    try{
      const w = window.open(url, "_blank", "noopener,noreferrer");
      if(!w) window.location.href = url;
    }catch(_e){
      window.location.href = url;
    }
  }

  const btn = document.getElementById("btnOpenSecuriReport");
  if(btn){
    btn.addEventListener("click", (e)=>{
      try{ e.preventDefault(); e.stopPropagation(); }catch(_){}
      openExternal(SECURIREPORT_URL);
    });
  }

  // Fallback: if the card itself is clicked, also open
  const zone = document.getElementById("securiReportZone");
  if(zone){
    zone.addEventListener("click", (e)=>{
      const t = e.target;
      if(t && (t.id === "btnOpenSecuriReport")) return;
      // Only open when user clicks inside the card (not while selecting text)
      if(window.getSelection && String(window.getSelection()).length) return;
      openExternal(SECURIREPORT_URL);
    });
  }
})();
;



function fmtDateTime(d){
  try{
    const dd = String(d.getDate()).padStart(2,"0");
    const mm = String(d.getMonth()+1).padStart(2,"0");
    const yy = d.getFullYear();
    const hh = String(d.getHours()).padStart(2,"0");
    const mi = String(d.getMinutes()).padStart(2,"0");
    return `${dd}.${mm}.${yy} ${hh}:${mi}`;
  }catch(_){ return ""; }
}

// ================================
// Delinquenten Datenbank (Firestore)


// ================================
function delinqCol(){ return collection(db, "delinquents"); }

let __unsubDelinq = null;
let __delinqCache = [];
let __editingDelinqId = null;
// F√§lle / Vorf√§lle
let __delinqCurrentCases = [];   // bereits gespeicherte F√§lle (bei Bearbeiten)
let __delinqPendingCases = [];   // neue, noch nicht gespeicherte F√§lle

function __norm(s){ return (s||"").trim(); }
function __normLower(s){ return __norm(s).toLowerCase(); }

function __safeArr(a){ return Array.isArray(a) ? a : []; }

function __caseSummary(c){
  const no = __norm(c?.caseNo);
  const dt = __norm(c?.date);
  const pl = __norm(c?.place);
  const parts = [];
  if(no) parts.push(`#${escapeHtml(no)}`);
  if(dt) parts.push(`üìÖ ${escapeHtml(dt)}`);
  if(pl) parts.push(`üìç ${escapeHtml(pl)}`);
  return parts.join(" ¬∑ ") || "(ohne Details)";
}

function renderDelinqCaseList(){
  const el = document.getElementById('delinqCaseList');
  if(!el) return;
  const existing = __safeArr(__delinqCurrentCases);
  const pending = __safeArr(__delinqPendingCases);
  const all = [...existing.map(c=>({c, t:'existing'})), ...pending.map((c,idx)=>({c, t:'pending', idx}))];
  if(!all.length){
    el.innerHTML = `<div class="hint" style="padding:8px;">Noch keine F√§lle hinzugef√ºgt.</div>`;
    return;
  }
  el.innerHTML = all.map(({c,t,idx})=>{
    return `
      <div class="delinqItem" style="padding:10px;">
        <div class="delinqMeta">
          <div class="delinqTitle" style="font-size:14px;">${t==='existing' ? 'üìå Gespeichert' : 'üÜï Neu'}</div>
          <div class="delinqSub">${__caseSummary(c)}</div>
        </div>
        <div class="delinqActions">
          ${t==='pending' ? `<button class="btn danger" type="button" data-delinqcase-remove="${idx}">Entfernen</button>` : ``}
        </div>
      </div>
    `;
  }).join('');
}

function clearDelinqCaseInputs(){
  const a = document.getElementById('delinqCaseNo'); if(a) a.value = '';
  const b = document.getElementById('delinqCaseDate'); if(b) b.value = '';
  const c = document.getElementById('delinqCasePlace'); if(c) c.value = '';
}

function addDelinqCaseFromInputs(){
  const caseNo = __norm(document.getElementById('delinqCaseNo')?.value);
  const date = __norm(document.getElementById('delinqCaseDate')?.value);
  const place = __norm(document.getElementById('delinqCasePlace')?.value);

  if(!caseNo){ alert('Bitte eine Fall Nr. eingeben.'); return; }
  if(!date){ alert('Bitte ein Datum ausw√§hlen.'); return; }
  if(!place){ alert('Bitte einen Ort eingeben.'); return; }

  // simple Duplicate-Check (CaseNo) innerhalb aktueller + pending
  const all = [...__safeArr(__delinqCurrentCases), ...__safeArr(__delinqPendingCases)];
  const exists = all.some(x => __normLower(x?.caseNo) === __normLower(caseNo));
  if(exists){ toast('‚ö†Ô∏è Diese Fall Nr. existiert bereits.'); return; }

  __delinqPendingCases.push({
    caseNo,
    date,
    place,
    addedAt: Date.now(),
    addedByUid: (state?.session?.uid || auth.currentUser?.uid || null),
    addedByEmail: (auth.currentUser?.email || null)
  });
  clearDelinqCaseInputs();
  renderDelinqCaseList();
}

function __canDeleteDelinq(d){
  try{
    const uid = state.session?.uid || null;
    return isAdminUser() || (!!uid && d && d.createdByUid === uid);
  }catch(_){
    return false;
  }
}

function renderDelinqList(){
  const listEl = document.getElementById("delinqList");
  if(!listEl) return;

  const q = __normLower(document.getElementById("delinqSearch")?.value || "");
  const rows = __delinqCache.filter(d => {
    if(!q) return true;
    const hay = (d.searchKey || "").toLowerCase();
    return hay.includes(q);
  });

  if(!rows.length){
    listEl.innerHTML = `<div class="hint" style="padding:10px;">Keine Eintr√§ge gefunden.</div>`;
    return;
  }

  listEl.innerHTML = rows.map(d => {
    const name = `${escapeHtml(d.lastName || "")} ${escapeHtml(d.firstName || "")}`.trim();
    const bd = escapeHtml(d.birthDate || "");
    const store = escapeHtml(d.store || "");
    const hb = !!d.houseBan;

    const myUid = state?.session?.uid || auth.currentUser?.uid || null;
    const canEdit = (typeof perms === "function" && perms().canAdmin) || (myUid && d.createdByUid === myUid);

    const cases = Array.isArray(d.cases) ? d.cases : [];
    const caseCount = cases.length;
    let lastCase = null;
    if(caseCount){
      // latest by date-string (YYYY-MM-DD) fallback by addedAt
      lastCase = cases.slice().sort((a,b)=>{
        const ad = (a?.date || "");
        const bd2 = (b?.date || "");
        if(ad && bd2) return ad.localeCompare(bd2);
        return (a?.addedAt||0) - (b?.addedAt||0);
      }).pop();
    }

    const subParts = [
      `üéÇ ${bd}`,
      hb ? `‚õî Hausverbot: Ja` : `‚õî Hausverbot: Nein`,
      caseCount ? `üßæ F√§lle: ${caseCount}` : `üßæ F√§lle: 0`,
      (caseCount && lastCase) ? `üÜï Letzter: ${[lastCase?.date ? `üìÖ ${escapeHtml(lastCase.date)}` : "", lastCase?.place ? `üìç ${escapeHtml(lastCase.place)}` : ""].filter(Boolean).join(" ¬∑ ")}` : ""
    ].filter(Boolean);
    const sub = subParts.join(" ¬∑ ");

    const casesHtml = caseCount ? (()=>{
      const sorted = cases.slice().sort((a,b)=>{
        const ad = (a?.date || "");
        const bd2 = (b?.date || "");
        if(ad && bd2) return bd2.localeCompare(ad); // newest first
        return (b?.addedAt||0) - (a?.addedAt||0);
      });
      const top = sorted.slice(0, 3);
      const more = Math.max(0, sorted.length - top.length);
      return `
        <details class="delinqCases">
          <summary>üìÇ F√§lle anzeigen (${sorted.length})${more ? ` ¬∑ +${more} weitere` : ``}</summary>
          <div class="delinqCasesList">
            ${top.map(c=>`<div class="delinqCaseRow">üßæ <b>${escapeHtml(c.caseNo || c.caseNr || "")}</b> ¬∑ ${c.date ? `üìÖ ${escapeHtml(c.date)}` : ""}${c.place ? ` ¬∑ üìç ${escapeHtml(c.place)}` : ""}</div>`).join("")}
            ${more ? `<div class="hint" style="font-size:12px;opacity:.8;padding:4px 2px;">Weitere F√§lle sind vorhanden. √ñffne ‚ÄûBearbeiten‚Äú, um alle zu sehen.</div>` : ``}
          </div>
        </details>
      `;
    })() : ``;

    return `
      <div class="delinqItem" data-delinq-id="${escapeHtml(d.id)}">
        <div class="delinqMeta">
          <div class="delinqTitle">${name}</div>
          <div class="delinqSub">${sub}</div>${casesHtml}
        </div>
        <div class="delinqActions">
          ${canEdit ? `<button class="btn" type="button" data-delinq-action="edit">Bearbeiten</button>` : ""}
          ${canEdit ? `<button class="btn danger" type="button" data-delinq-action="delete">L√∂schen</button>` : ""}
        </div>
      </div>
    `;
  }).join("");
}

function openDelinqOverlay(){
  requireLogin();
  const ov = document.getElementById("delinqOverlay");
  if(!ov) return;
  ov.classList.remove("hidden");

  // Case-Liste initial rendern (damit der Bereich nicht leer wirkt)
  try{ renderDelinqCaseList(); }catch(_e){}

  if(__unsubDelinq) __unsubDelinq();
  const q = query(delinqCol(), orderBy("lastNameLower","asc"), orderBy("firstNameLower","asc"), orderBy("birthDate","asc"));
  __unsubDelinq = onSnapshot(q, (snap)=>{
    const arr = [];
    snap.forEach(docu => arr.push({ id: docu.id, ...docu.data() }));
    __delinqCache = arr;
    renderDelinqList();
  });
}

function closeDelinqOverlay(){
  const ov = document.getElementById("delinqOverlay");
  if(ov) ov.classList.add("hidden");
  if(__unsubDelinq){ __unsubDelinq(); __unsubDelinq = null; }
}

function clearDelinqForm(){
  const f = document.getElementById("delinqFirstName"); if(f) f.value = "";
  const l = document.getElementById("delinqLastName"); if(l) l.value = "";
  const b = document.getElementById("delinqBirthDate"); if(b) b.value = "";
const hb = document.getElementById("delinqHouseBan"); if(hb) hb.checked = false;

  // F√§lle zur√ºcksetzen
  __delinqCurrentCases = [];
  __delinqPendingCases = [];
  clearDelinqCaseInputs();
  renderDelinqCaseList();

  __editingDelinqId = null;
  const btn = document.getElementById("btnSaveDelinq");
  if(btn) btn.textContent = "Speichern";
}

async function saveDelinq(){
  const userId = requireLogin();
  const firstName = __norm(document.getElementById("delinqFirstName")?.value);
  const lastName  = __norm(document.getElementById("delinqLastName")?.value);
  const birthDate = __norm(document.getElementById("delinqBirthDate")?.value); // YYYY-MM-DD
const houseBan  = !!document.getElementById("delinqHouseBan")?.checked;

  if(!firstName || !lastName || !birthDate){
    alert("Bitte Vorname, Nachname und Geburtsdatum ausf√ºllen.");
    return;
  }
const fnL = __normLower(firstName);
  const lnL = __normLower(lastName);
// F√§lle: bestehende + neue (pending)
  const existingCases = __safeArr(__delinqCurrentCases);
  const pendingCases = __safeArr(__delinqPendingCases);
  const finalCases = __editingDelinqId ? [...existingCases, ...pendingCases] : [...pendingCases];
  const casesKey = finalCases.map(c => `${__normLower(c?.caseNo)} ${__normLower(c?.date)} ${__normLower(c?.place)}`).join(" ").trim();

  // Duplikat-Check (nur beim Neuanlegen): gleicher Vorname/Nachname/Geburtsdatum
  if(!__editingDelinqId){
    const dupQ = query(
      delinqCol(),
      where("firstNameLower", "==", fnL),
      where("lastNameLower", "==", lnL),
      where("birthDate", "==", birthDate),
limit(1)
    );
    const dupSnap = await getDocs(dupQ);
    if(!dupSnap.empty){
      toast("‚ö†Ô∏è Bereits vorhanden (Duplikat).");
      return;
    }
  }

  const docData = {
    firstName,
    lastName,
    birthDate,
houseBan: houseBan,

    firstNameLower: fnL,
    lastNameLower: lnL,

    // Suchtext: Name + Datum + "hausverbot" + F√§lle
    searchKey: `${lnL} ${fnL} ${birthDate} ${houseBan ? "hausverbot" : ""} ${casesKey}`.trim(),

    // F√§lle / Vorf√§lle
    cases: finalCases,
    casesCount: (finalCases?.length || 0),

    createdAt: serverTimestamp(),
    createdByUid: userId,
    createdByEmail: (auth.currentUser?.email || null)
  };

  try{
    if(__editingDelinqId){
      // Owner/createdBy* bleiben im Doc erhalten (Rules blocken sonst). Wir setzten hier nichts um.
      // Firestore update: nur Felder, die sich √§ndern sollen.
      await updateDoc(doc(db, "delinquents", __editingDelinqId), {
        firstName, lastName, birthDate,
        houseBan,
firstNameLower: fnL, lastNameLower: lnL,
        searchKey: docData.searchKey,
        cases: finalCases,
        casesCount: (finalCases?.length || 0)
      });
      toast("‚úÖ Delinquent aktualisiert.");
    }else{
      await addDoc(delinqCol(), docData);
      toast("‚úÖ Delinquent gespeichert.");
    }
    clearDelinqForm();
  }catch(err){
    console.error(err);
    alert("Speichern fehlgeschlagen: " + (err?.message || err));
  }
}

async function deleteDelinqById(id){
  requireLogin();
  const d = __delinqCache.find(x => x.id === id);
  if(!d){
    toast("‚ö†Ô∏è Eintrag nicht gefunden.");
    return;
  }
  if(!__canDeleteDelinq(d)){
    toast("‚õî Keine Berechtigung zum L√∂schen.");
    return;
  }
  const ok = confirm(`Eintrag wirklich l√∂schen?\n\n${(d.lastName||"").toUpperCase()} ${d.firstName||""} (${d.birthDate||""})`);
  if(!ok) return;

  await deleteDoc(doc(db, "delinquents", id));
  toast("üóëÔ∏è Gel√∂scht.");
}

(function bindDelinqUi(){
  const btnOpen = document.getElementById("btnOpenDelinq");
  const zone = document.getElementById("delinqZone");
  const btnClose = document.getElementById("btnCloseDelinq");
  const btnSave = document.getElementById("btnSaveDelinq");
  const btnClear = document.getElementById("btnClearDelinq");
  const btnAddCase = document.getElementById("btnAddDelinqCase");
  const caseList = document.getElementById("delinqCaseList");
  const search = document.getElementById("delinqSearch");
  const list = document.getElementById("delinqList");

  if(btnOpen) btnOpen.addEventListener("click", (e)=>{ e.preventDefault(); openDelinqOverlay(); });
  if(zone) zone.addEventListener("click", (e)=>{
    const t = e.target;
    if(t && t.id === "btnOpenDelinq") return;
    if(window.getSelection && String(window.getSelection()).length) return;
    openDelinqOverlay();
  });

  if(btnClose) btnClose.addEventListener("click", closeDelinqOverlay);
  if(btnSave) btnSave.addEventListener("click", saveDelinq);
  if(btnClear) btnClear.addEventListener("click", clearDelinqForm);
  if(btnAddCase) btnAddCase.addEventListener("click", addDelinqCaseFromInputs);
  if(search) search.addEventListener("input", renderDelinqList);

  // Pending-Fall entfernen (nur lokal, wird erst bei Speichern geschrieben)
  if(caseList){
    caseList.addEventListener('click', (e)=>{
      const b = e.target?.closest?.('button[data-delinqcase-remove]');
      if(!b) return;
      const idx = parseInt(b.getAttribute('data-delinqcase-remove'), 10);
      if(Number.isNaN(idx)) return;
      __delinqPendingCases.splice(idx, 1);
      renderDelinqCaseList();
    });
  }

  // Edit/Delete delegation (works for dynamically rendered list items)
  if(list){
    list.addEventListener("click", async (e)=>{
      const btn = e.target?.closest?.('button[data-delinq-action]');
      if(!btn) return;
      const action = btn.getAttribute("data-delinq-action");
      const wrap = btn.closest("[data-delinq-id]");
      const id = wrap?.getAttribute("data-delinq-id");
      if(!id) return;

      const d = __delinqCache.find(x => x.id === id);
      if(!d){ toast("‚ö†Ô∏è Eintrag nicht gefunden."); return; }

      const myUid = state?.session?.uid || auth.currentUser?.uid || null;
      const canEdit = (typeof perms === "function" && perms().canAdmin) || (myUid && d.createdByUid === myUid);
      if(!canEdit){ toast("‚õî Keine Berechtigung."); return; }

      if(action === "edit"){
        __editingDelinqId = id;
        const f = document.getElementById("delinqFirstName"); if(f) f.value = d.firstName || "";
        const l = document.getElementById("delinqLastName");  if(l) l.value = d.lastName || "";
        const b = document.getElementById("delinqBirthDate"); if(b) b.value = d.birthDate || "";
        const s = null;     if(s) s.value = d.store || "";
        const hb = document.getElementById("delinqHouseBan"); if(hb) hb.checked = !!d.houseBan;

        // F√§lle laden (bearbeiten) + Liste anzeigen
        __delinqCurrentCases = __safeArr(d.cases).slice();
        __delinqPendingCases = [];
        clearDelinqCaseInputs();
        renderDelinqCaseList();

        const saveBtn = document.getElementById("btnSaveDelinq"); if(saveBtn) saveBtn.textContent = "Aktualisieren";
        try{ f?.focus?.(); }catch(_){}
        return;
      }

      if(action === "delete"){
        try{
          await deleteDelinqById(id);
          if(__editingDelinqId === id) clearDelinqForm();
        }catch(err){
          console.error(err);
          alert("L√∂schen fehlgeschlagen: " + (err?.message || err));
        }
      }
    });
  }


  // ESC schlie√üt
  document.addEventListener("keydown", (e)=>{
    if(e.key === "Escape"){
      const ov = document.getElementById("delinqOverlay");
      if(ov && !ov.classList.contains("hidden")) closeDelinqOverlay();
    }
  });
})();

</script>

<!-- Mobile Bottom Navigation -->
<nav id="mobileBottomNav">
  <button class="mbtn" id="mbStart" type="button"><span>üè†</span>Home</button>
  <button class="mbtn" id="mbDocs" type="button"><span>üìã</span>Infos</button>
  <button class="mbtn" id="mbRank" type="button"><span>üèÜ</span>Rang</button>
  <button class="mbtn" id="mbCase" type="button"><span>üìù</span>Fall</button>
  <button class="mbtn" id="mbChat" type="button"><span>üí¨</span>Chat</button>
  <button class="mbtn" id="mbSettings" type="button"><span>‚öôÔ∏è</span>Settings</button>
</nav>

</body>
</html>
